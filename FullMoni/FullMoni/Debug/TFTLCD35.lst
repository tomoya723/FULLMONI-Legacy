H8S,H8/300 SERIES C/C++ COMPILER (V.7.00.00.000)    2-Feb-2021 10:47:28 PAGE   1

******* STACK FRAME INFORMATION ********

FILE NAME: D:\WorkSpace\FullMoni\FullMoni\TFTLCD35.c

Function (File D:\WorkSpa, Line    54): delay

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000000 Byte(s)
Total Frame Size        : 0x00000004 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line    66): write_comm

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000000 Byte(s)
Total Frame Size        : 0x00000004 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line    75): write_data

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000000 Byte(s)
Total Frame Size        : 0x00000004 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line    83): Init_TFTLCD

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000000 Byte(s)
Total Frame Size        : 0x00000004 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   192): Display_Home

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000000 Byte(s)
Total Frame Size        : 0x00000004 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   230): LCD_Refresh

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000000 Byte(s)
Total Frame Size        : 0x00000004 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   240): LCD_locate

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000000 Byte(s)
Total Frame Size        : 0x00000004 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   249): LCD_FadeIN

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000000 Byte(s)
Total Frame Size        : 0x00000004 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   265): LCD_FadeOUT

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000004 Byte(s)
Total Frame Size        : 0x00000008 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   281): FONT_open

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000008 Byte(s)
Total Frame Size        : 0x0000000c Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   317): LCD_line

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000008 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000014 Byte(s)
Total Frame Size        : 0x00000020 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   394): LCD_line2

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x0000000a Byte(s)
Temporary Size          : 0x00000006 Byte(s)
Register Save Area Size : 0x00000014 Byte(s)
Total Frame Size        : 0x00000028 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   484): swap

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000004 Byte(s)
Total Frame Size        : 0x00000008 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   517): LCD_CLR

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000002 Byte(s)
Register Save Area Size : 0x00000000 Byte(s)
Total Frame Size        : 0x00000006 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   564): LCD_PAINT

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000004 Byte(s)
Register Save Area Size : 0x00000014 Byte(s)
Total Frame Size        : 0x0000001c Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   615): LCD_Gcopy

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000014 Byte(s)
Total Frame Size        : 0x00000018 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   639): LCD_textout

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x0000000c Byte(s)
Total Frame Size        : 0x00000010 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   683): LCD_CHR_Copy_Smallfont

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x0000000c Byte(s)
Total Frame Size        : 0x00000010 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   791): LCD_CHR_copyBN

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x0000000c Byte(s)
Total Frame Size        : 0x00000010 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   819): LCD_CHR_copyBNR

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x0000000c Byte(s)
Total Frame Size        : 0x00000010 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   847): LCD_CHR_copyBN2

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000000 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000014 Byte(s)
Total Frame Size        : 0x00000018 Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line   932): LCD_INT_draw

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000006 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000012 Byte(s)
Total Frame Size        : 0x0000001c Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line  1035): LCD_INT_drawBN

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000006 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000012 Byte(s)
Total Frame Size        : 0x0000001c Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line  1138): LCD_INT_drawBNR

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000006 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000012 Byte(s)
Total Frame Size        : 0x0000001c Byte(s)

Used Runtime Library Name


Function (File D:\WorkSpa, Line  1241): LCD_INT_drawBN2

  Optimize Option Specified : No Allocation Information Available

Parameter Area Size     : 0x00000000 Byte(s)
Linkage Area Size       : 0x00000004 Byte(s)
Local Variable Size     : 0x00000006 Byte(s)
Temporary Size          : 0x00000000 Byte(s)
Register Save Area Size : 0x00000012 Byte(s)
Total Frame Size        : 0x0000001c Byte(s)

Used Runtime Library Name


H8S,H8/300 SERIES C/C++ COMPILER (V.7.00.00.000)    2-Feb-2021 10:47:28 PAGE   1

************ OBJECT LISTING ************

FILE NAME: D:\WorkSpace\FullMoni\FullMoni\TFTLCD35.c

SCT OFFSET CODE               LABEL     INSTRUCTION OPERAND    COMMENT

P                                                                  ; section
         1:    // --------------------------------------------------------------------
         2:    // Copylight (C) 2021, Tomoya Sato( https://blog.goo.ne.jp/nacci_tomoya )
         3:    //
         4:    // This file is part of FullMoni firmwere.
         5:    //
         6:    // FullMoni is free software: you can redistribute it and/or modify
         7:    // it under the terms of the GNU General Public License as published by
         8:    // the Free Software Foundation, either version 3 of the License, or
         9:    // (at your option ) any later version.
        10:    //
        11:    // FullMoni is distributed in the hope that it will be useful,
        12:    // but WITHIOUT ANY WARRANTY; without even the implied warranty of
        13:    // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the
        14:    // GNU General Public License for more details.
        15:    //
        16:    // You should have received a copy of the GNU General Public License
        17:    // along with FullMoni. if not, see <http:/www.gnu.org/licenses/>.
        18:    //
        19:    // filename     :   TFTLCD35.c
        20:    // brief        :   FullMoni rev.C TFT液晶管理
        21:    // author       :   Tomoya Sato
        22:    // update       :   2021/02/02
        23:    // version      :   1.05
        24:    // --------------------------------------------------------------------
        25:    
        26:    // --------------------------------------------------------------------
        27:    // システムヘッダファイル
        28:    // --------------------------------------------------------------------
        29:    #include <machine.h>
        30:    
        31:    // --------------------------------------------------------------------
        32:    // ユーザーヘッダファイル
        33:    // --------------------------------------------------------------------
        34:    #include "iodefine.h"
        35:    #include "TFTLCD35.h"
        36:    
        37:    // --------------------------------------------------------------------
        38:    // defineマクロ宣言
        39:    // --------------------------------------------------------------------
        40:    #define LCD_RS  P1.DR.BIT.B0        //  コマンド信号 (RS for Parallel Interface)
        41:    #define LCD_RES P2.DR.BIT.B4        //  リセット信号
        42:    
        43:    // --------------------------------------------------------------------
        44:    // グローバル変数宣言
        45:    // --------------------------------------------------------------------
        46:    volatile unsigned int g_LCD_x;
        47:    volatile unsigned int g_LCD_y;
        48:    volatile unsigned int g_drawbuff_flg;
        49:    volatile unsigned int g_oneshot_flg;
        50:    
        51:    // --------------------------------------------------------------------
        52:    // ソフトディレイ関数
        53:    // --------------------------------------------------------------------
        54:    void delay(unsigned int t)
  00000000                    _delay:                              ; function: delay
  00000000                    L6999:                                
        55:    {
        56:        unsigned int t1;
        57:        while(t --)
  00000000 0D00                   MOV.W       R0,R0
  00000002 4700                   BEQ         L7001:8
  00000004 1B50                   DEC.W       #1,R0
        58:        for(t1 = 11000; t1 > 0; t1 --)
  00000006 79082AF8               MOV.W       #H'2AF8:16,E0
  0000000A                    L7002:                                
        59:        {
        60:            nop();
  0000000A 0000                   NOP
  0000000C 1B58                   DEC.W       #1,E0
  0000000E 4600                   BNE         L7002:8
  00000010 4000                   BRA         L6999:8
  00000012                    L7001:                                
  00000012 5470                   RTS
        61:        }
        62:    }
        63:    // --------------------------------------------------------------------
        64:    // TFT LCD バス コマンド出力
        65:    // --------------------------------------------------------------------
        66:    void write_comm(unsigned int command)
  00000014                    _write_comm:                         ; function: write_comm
        67:    {
        68:        LCD_RS = 0;     // CLR_RS;
  00000014 7F507200               BCLR.B      #0,@H'00FFFF50:8
        69:        LCD_D = command;
  00000018 6BA000400000           MOV.W       R0,@H'00400000:32
  0000001E 5470                   RTS
        70:    }
        71:    
        72:    // --------------------------------------------------------------------
        73:    // TFT LCD バス データ出力
        74:    // --------------------------------------------------------------------
        75:    void write_data(unsigned int data)
  00000020                    _write_data:                         ; function: write_data
        76:    {
        77:        LCD_RS = 1;     // SET_RS;
  00000020 7F507000               BSET.B      #0,@H'00FFFF50:8
        78:        LCD_D = data;
  00000024 6BA000400000           MOV.W       R0,@H'00400000:32
  0000002A 5470                   RTS
        79:    }
        80:    // --------------------------------------------------------------------
        81:    // TFT LCD 初期化
        82:    // --------------------------------------------------------------------
        83:    void Init_TFTLCD()
  0000002C                    _Init_TFTLCD:                        ; function: Init_TFTLCD
        84:    {
        85:        
        86:        LCD_RS = 1;     // SET_RS;
  0000002C 7F507000               BSET.B      #0,@H'00FFFF50:8
        87:        LCD_RES = 0;    //  CLR_RESET;
  00000030 7F517240               BCLR.B      #4,@H'00FFFF51:8
        88:        delay(200);
  00000034 790000C8               MOV.W       #H'00C8:16,R0
  00000038 5500                   BSR         _delay:8
        89:        LCD_RES = 1;    //  SET_RESET;
  0000003A 7F517040               BSET.B      #4,@H'00FFFF51:8
        90:        delay(500);
  0000003E 790001F4               MOV.W       #H'01F4:16,R0
  00000042 5500                   BSR         _delay:8
        91:        
        92:        write_comm(0x0028);     // VCOM OTP
  00000044 79000028               MOV.W       #H'0028:16,R0
  00000048 5500                   BSR         _write_comm:8
        93:        write_data(0x0006);     // Page 55-56 of SSD2119 datasheet
  0000004A 0F60                   MOV.W       #6:3,R0
  0000004C 5500                   BSR         _write_data:8
        94:        
        95:        write_comm(0x0000);     // start Oscillator
  0000004E 1900                   SUB.W       R0,R0
  00000050 5500                   BSR         _write_comm:8
        96:        write_data(0x0001);     // Page 36 of SSD2119 datasheet
  00000052 0F10                   MOV.W       #1:3,R0
  00000054 5500                   BSR         _write_data:8
        97:        
        98:        write_comm(0x0010);     // Sleep mode
  00000056 79000010               MOV.W       #H'0010:16,R0
  0000005A 5500                   BSR         _write_comm:8
        99:        write_data(0x0000);     // Page 49 of SSD2119 datasheet
  0000005C 1900                   SUB.W       R0,R0
  0000005E 5500                   BSR         _write_data:8
       100:        
       101:        write_comm(0x0001);     // Driver Output Control
  00000060 0F10                   MOV.W       #1:3,R0
  00000062 5500                   BSR         _write_comm:8
       102:        write_data(0x32EF);     // Page 36-39 of SSD2119 datasheet
  00000064 790032EF               MOV.W       #H'32EF:16,R0
  00000068 5500                   BSR         _write_data:8
       103:    //  write_data(0x7AEF);     // Page 36-39 of SSD2119 datasheet
       104:        
       105:        write_comm(0x0002);     // LCD Driving Waveform Control
  0000006A 0F20                   MOV.W       #2:3,R0
  0000006C 5500                   BSR         _write_comm:8
       106:        write_data(0x0600);     // Page 40-42 of SSD2119 datasheet
  0000006E 79000600               MOV.W       #H'0600:16,R0
  00000072 5500                   BSR         _write_data:8
       107:        
       108:        write_comm(0x0003);     // Power Control 1
  00000074 0F30                   MOV.W       #3:3,R0
  00000076 5500                   BSR         _write_comm:8
       109:        write_data(0x6A38);     // Page 43-44 of SSD2119 datasheet
  00000078 79006A38               MOV.W       #H'6A38:16,R0
  0000007C 5500                   BSR         _write_data:8
       110:        
       111:        write_comm(0x0011);     // Entry Mode
  0000007E 79000011               MOV.W       #H'0011:16,R0
  00000082 5500                   BSR         _write_comm:8
       112:    //  write_data(0x6870);     // Page 50-52 of SSD2119 datasheet
       113:        write_data(0x6860);     // Page 50-52 of SSD2119 datasheet  // 左右反転対策
  00000084 79006860               MOV.W       #H'6860:16,R0
  00000088 5500                   BSR         _write_data:8
       114:        
       115:        write_comm(0X000F);     // Gate Scan Position
  0000008A 7900000F               MOV.W       #H'000F:16,R0
  0000008E 5E000000               JSR         @_write_comm:24
       116:        write_data(0x0000);     // Page 49 of SSD2119 datasheet
  00000092 1900                   SUB.W       R0,R0
  00000094 5E000000               JSR         @_write_data:24
       117:        
       118:        write_comm(0X000B);     // Frame Cycle Control
  00000098 7900000B               MOV.W       #H'000B:16,R0
  0000009C 5E000000               JSR         @_write_comm:24
       119:        write_data(0x5308);     // Page 45 of SSD2119 datasheet
  000000A0 79005308               MOV.W       #H'5308:16,R0
  000000A4 5E000000               JSR         @_write_data:24
       120:        
       121:        write_comm(0x000C);     // Power Control 2
  000000A8 7900000C               MOV.W       #H'000C:16,R0
  000000AC 5E000000               JSR         @_write_comm:24
       122:        write_data(0x0003);     // Page 47 of SSD2119 datasheet
  000000B0 0F30                   MOV.W       #3:3,R0
  000000B2 5E000000               JSR         @_write_data:24
       123:        
       124:        write_comm(0x000D);     // Power Control 3
  000000B6 7900000D               MOV.W       #H'000D:16,R0
  000000BA 5E000000               JSR         @_write_comm:24
       125:        write_data(0x000A);     // Page 48 of SSD2119 datasheet
  000000BE 7900000A               MOV.W       #H'000A:16,R0
  000000C2 5E000000               JSR         @_write_data:24
       126:        
       127:        write_comm(0x000E);     // Power Control 4
  000000C6 7900000E               MOV.W       #H'000E:16,R0
  000000CA 5E000000               JSR         @_write_comm:24
       128:        write_data(0x2E00);     // Page 48 of SSD2119 datasheet
  000000CE 79002E00               MOV.W       #H'2E00:16,R0
  000000D2 5E000000               JSR         @_write_data:24
       129:        
       130:        write_comm(0x001E);     // Power Control 5
  000000D6 7900001E               MOV.W       #H'001E:16,R0
  000000DA 5E000000               JSR         @_write_comm:24
       131:        write_data(0x00BE);     // Page 53 of SSD2119 datasheet
  000000DE 790000BE               MOV.W       #H'00BE:16,R0
  000000E2 5E000000               JSR         @_write_data:24
       132:        
       133:        write_comm(0x0025);     // Frame Frequency Control
  000000E6 79000025               MOV.W       #H'0025:16,R0
  000000EA 5E000000               JSR         @_write_comm:24
       134:        write_data(0x8000);     // Page 53 of SSD2119 datasheet
  000000EE 79008000               MOV.W       #H'8000:16,R0
  000000F2 5E000000               JSR         @_write_data:24
       135:        
       136:        write_comm(0x0026);     // Analog setting
  000000F6 79000026               MOV.W       #H'0026:16,R0
  000000FA 5E000000               JSR         @_write_comm:24
       137:        write_data(0x7800);     // Page 54 of SSD2119 datasheet
  000000FE 79007800               MOV.W       #H'7800:16,R0
  00000102 5E000000               JSR         @_write_data:24
       138:        
       139:        write_comm(0x004E);     // Ram Address Set
  00000106 7900004E               MOV.W       #H'004E:16,R0
  0000010A 5E000000               JSR         @_write_comm:24
       140:        write_data(0x0000);     // Page 58 of SSD2119 datasheet
  0000010E 1900                   SUB.W       R0,R0
  00000110 5E000000               JSR         @_write_data:24
       141:        
       142:        write_comm(0x004F);     // Ram Address Set
  00000114 7900004F               MOV.W       #H'004F:16,R0
  00000118 5E000000               JSR         @_write_comm:24
       143:        write_data(0x0000);     // Page 58 of SSD2119 datasheet
  0000011C 1900                   SUB.W       R0,R0
  0000011E 5E000000               JSR         @_write_data:24
       144:        
       145:        write_comm(0x0012);     // Sleep mode
  00000122 79000012               MOV.W       #H'0012:16,R0
  00000126 5E000000               JSR         @_write_comm:24
       146:        write_data(0x08D9);     // Page 49 of SSD2119 datasheet
  0000012A 790008D9               MOV.W       #H'08D9:16,R0
  0000012E 5E000000               JSR         @_write_data:24
       147:        
       148:        // Gamma Control (R30h to R3Bh)
       149:        // Page 56 of SSD2119 datasheet
       150:        write_comm(0x0030);
  00000132 79000030               MOV.W       #H'0030:16,R0
  00000136 5E000000               JSR         @_write_comm:24
       151:        write_data(0x0000);
  0000013A 1900                   SUB.W       R0,R0
  0000013C 5E000000               JSR         @_write_data:24
       152:        
       153:        write_comm(0x0031);
  00000140 79000031               MOV.W       #H'0031:16,R0
  00000144 5E000000               JSR         @_write_comm:24
       154:        write_data(0x0104);
  00000148 79000104               MOV.W       #H'0104:16,R0
  0000014C 5E000000               JSR         @_write_data:24
       155:        
       156:        write_comm(0x0032);
  00000150 79000032               MOV.W       #H'0032:16,R0
  00000154 5E000000               JSR         @_write_comm:24
       157:        write_data(0x0100);
  00000158 79000100               MOV.W       #H'0100:16,R0
  0000015C 5E000000               JSR         @_write_data:24
       158:        
       159:        write_comm(0x0033);
  00000160 79000033               MOV.W       #H'0033:16,R0
  00000164 5E000000               JSR         @_write_comm:24
       160:        write_data(0x0305);
  00000168 79000305               MOV.W       #H'0305:16,R0
  0000016C 5E000000               JSR         @_write_data:24
       161:        
       162:        write_comm(0x0034);
  00000170 79000034               MOV.W       #H'0034:16,R0
  00000174 5E000000               JSR         @_write_comm:24
       163:        write_data(0x0505);
  00000178 79000505               MOV.W       #H'0505:16,R0
  0000017C 5E000000               JSR         @_write_data:24
       164:        
       165:        write_comm(0x0035);
  00000180 79000035               MOV.W       #H'0035:16,R0
  00000184 5E000000               JSR         @_write_comm:24
       166:        write_data(0x0305);
  00000188 79000305               MOV.W       #H'0305:16,R0
  0000018C 5E000000               JSR         @_write_data:24
       167:        
       168:        write_comm(0x0036);
  00000190 79000036               MOV.W       #H'0036:16,R0
  00000194 5E000000               JSR         @_write_comm:24
       169:        write_data(0x0707);
  00000198 79000707               MOV.W       #H'0707:16,R0
  0000019C 5E000000               JSR         @_write_data:24
       170:        
       171:        write_comm(0x0037);
  000001A0 79000037               MOV.W       #H'0037:16,R0
  000001A4 5E000000               JSR         @_write_comm:24
       172:        write_data(0x0300);
  000001A8 79000300               MOV.W       #H'0300:16,R0
  000001AC 5E000000               JSR         @_write_data:24
       173:        
       174:        write_comm(0x003A);
  000001B0 7900003A               MOV.W       #H'003A:16,R0
  000001B4 5E000000               JSR         @_write_comm:24
       175:        write_data(0x1200);
  000001B8 79001200               MOV.W       #H'1200:16,R0
  000001BC 5E000000               JSR         @_write_data:24
       176:        
       177:        write_comm(0x003B);
  000001C0 7900003B               MOV.W       #H'003B:16,R0
  000001C4 5E000000               JSR         @_write_comm:24
       178:        write_data(0x0800);      
  000001C8 79000800               MOV.W       #H'0800:16,R0
  000001CC 5E000000               JSR         @_write_data:24
       179:        
       180:        write_comm(0x0007);     // Display Control 
  000001D0 0F70                   MOV.W       #7:3,R0
  000001D2 5E000000               JSR         @_write_comm:24
       181:        write_data(0x0033);     // Page 45 of SSD2119 datasheet
  000001D6 79000033               MOV.W       #H'0033:16,R0
  000001DA 5E000000               JSR         @_write_data:24
       182:        
       183:        delay(150);
  000001DE 79000096               MOV.W       #H'0096:16,R0
  000001E2 5E000000               JSR         @_delay:24
       184:        //_delay_ms(150);
       185:        
       186:        write_comm(0x0022);     // RAM data write/read
  000001E6 79000022               MOV.W       #H'0022:16,R0
  000001EA 5A000000               JMP         @_write_comm:24
       187:    }
       188:    
       189:    // --------------------------------------------------------------------
       190:    // TDT LCD リフレッシュ処理
       191:    // --------------------------------------------------------------------
       192:    void Display_Home()
  000001EE                    _Display_Home:                       ; function: Display_Home
       193:    {
       194:        write_comm(0x004E);     // RAM address set
  000001EE 7900004E               MOV.W       #H'004E:16,R0
  000001F2 5E000000               JSR         @_write_comm:24
       195:        write_data(0x0000);     // Page 58 of SSD2119 datasheet
  000001F6 1900                   SUB.W       R0,R0
  000001F8 5E000000               JSR         @_write_data:24
       196:        write_comm(0x004F);     // RAM address set
  000001FC 7900004F               MOV.W       #H'004F:16,R0
  00000200 5E000000               JSR         @_write_comm:24
       197:        write_data(0x0000);     // Page 58 of SSD2119 datasheet
  00000204 1900                   SUB.W       R0,R0
  00000206 5E000000               JSR         @_write_data:24
       198:        
       199:        write_comm(0x0044);     // Vertical RAM address position
  0000020A 79000044               MOV.W       #H'0044:16,R0
  0000020E 5E000000               JSR         @_write_comm:24
       200:        write_data(0xEF00);     // Page 57 of SSD2119 datasheet
  00000212 7900EF00               MOV.W       #H'EF00:16,R0
  00000216 5E000000               JSR         @_write_data:24
       201:        write_comm(0x0045);     // Horizontal RAM address position 
  0000021A 79000045               MOV.W       #H'0045:16,R0
  0000021E 5E000000               JSR         @_write_comm:24
       202:        write_data(0x0000);     // Page 57 of SSD2119 datasheet
  00000222 1900                   SUB.W       R0,R0
  00000224 5E000000               JSR         @_write_data:24
       203:        write_comm(0x0046);     // Horizontal RAM address position
  00000228 79000046               MOV.W       #H'0046:16,R0
  0000022C 5E000000               JSR         @_write_comm:24
       204:        write_data(0x013F);     // Page 57 of SSD2119 datasheet
  00000230 7900013F               MOV.W       #H'013F:16,R0
  00000234 5E000000               JSR         @_write_data:24
       205:        
       206:        write_comm(0x0022);     // RAM data write/read
  00000238 79000022               MOV.W       #H'0022:16,R0
  0000023C 5E000000               JSR         @_write_comm:24
       207:        
       208:        LCD_RS = 1;     // SET_RS;
  00000240 7F507000               BSET.B      #0,@H'00FFFF50:8
       209:        
       210:        g_oneshot_flg ++;
  00000244 6B38000000000A10       ADD.W       #1:3,@_g_oneshot_flg:32
       211:        
       212:        // フレームバッファの切り替え
       213:        if(g_drawbuff_flg == 0)
  0000024C 6B2100000000           MOV.W       @_g_drawbuff_flg:32,R1
  00000252 4600                   BNE         L7011:8
       214:        {
       215:            EXDMAC0.EDSAR       = 0x200000;     //*ADATA        // EXDMA ソースアドレスレジスタ1
  00000254 7A74002000004000       MOV.L       #H'00200000:32,@H'00FFFC80:16
           FC80               
  0000025E 4000                   BRA         L7012:8
  00000260                    L7011:                                
       216:        }
       217:        else
       218:        {
       219:            EXDMAC0.EDSAR       = 0x225800;     //*BDATA        // EXDMA ソースアドレスレジスタ2
  00000260 7A74002258004000       MOV.L       #H'00225800:32,@H'00FFFC80:16
           FC80               
  0000026A                    L7012:                                
       220:        }
       221:        EXDMAC0.EDDAR           = 0x400000;     //LCD_D         // EXDMA デスティネーションアドレスレジスタ
  0000026A 7A74004000004000       MOV.L       #H'00400000:32,@H'00FFFC84:16
           FC84               
       222:        EXDMAC0.EDTCR           = 0x00025800;                   // EXDMA 転送カウントレジスタ 320*240*2=0x00025800
  00000274 7A74000258004000       MOV.L       #H'00025800:32,@H'00FFFC8C:16
           FC8C               
       223:        
       224:        EXDMAC0.EDMDR.BIT.DTE   = 1;
  0000027E 6A18FC947070           BSET.B      #7,@H'00FFFC94:16
  00000284 5470                   RTS
       225:    }
       226:    
       227:    // --------------------------------------------------------------------
       228:    // TDT LCD リフレッシュ同期フレームバッファ更新処理
       229:    // --------------------------------------------------------------------
       230:    void LCD_Refresh(void)
  00000286                    _LCD_Refresh:                        ; function: LCD_Refresh
  00000286                    L7014:                                
       231:    {
       232:        while(g_refresh_done == 0);
  00000286 7A0100000000           MOV.L       #_g_drawbuff_flg,ER1
  0000028C 6B2000000000           MOV.W       @_g_refresh_done:32,R0
  00000292 4700                   BEQ         L7014:8
       233:        g_refresh_done = 0;
  00000294 6BF000000000           MOV.W       #0:4,@_g_refresh_done:32
       234:        if(g_drawbuff_flg == 0){g_drawbuff_flg=1;}else{g_drawbuff_flg=0;}
  0000029A 6910                   MOV.W       @ER1,R0
  0000029C 4600                   BNE         L7017:8
  0000029E 015D0101               MOV.W       #1:8,@ER1
  000002A2 5470                   RTS
  000002A4                    L7017:                                
  000002A4 015D0100               MOV.W       #0:8,@ER1
  000002A8 5470                   RTS
       235:    }
       236:    
       237:    // --------------------------------------------------------------------
       238:    // TFT LCD 描画座標設定
       239:    // --------------------------------------------------------------------
       240:    void LCD_locate(unsigned int x, unsigned int y)
  000002AA                    _LCD_locate:                         ; function: LCD_locate
       241:    {
       242:        g_LCD_x = x;
  000002AA 6BA000000000           MOV.W       R0,@_g_LCD_x:32
       243:        g_LCD_y = y;
  000002B0 6BA800000000           MOV.W       E0,@_g_LCD_y:32
  000002B6 5470                   RTS
       244:    }
       245:    
       246:    // --------------------------------------------------------------------
       247:    // TFT LCD バックライト点灯
       248:    // --------------------------------------------------------------------
       249:    void LCD_FadeIN(void)
  000002B8                    _LCD_FadeIN:                         ; function: LCD_FadeIN
       250:    {
       251:        static unsigned long y, z;
       252:        
       253:        for(z = 0x2579; z >= 0x10; z -- )
  000002B8 7A092579               MOV.L       #H'2579:16,ER1
  000002BC                    L7023:                                
       254:        {
       255:            for(y = 0; y <= 10; y ++ )
  000002BC F80B                   MOV.B       #H'0B:8,R0L
  000002BE                    L7024:                                
       256:            {
       257:                TPU4.TGRB = z & 0xFFFF;
  000002BE 6B81FEEA               MOV.W       R1,@H'00FFFEEA:16
  000002C2 1A08                   DEC.B       R0L
  000002C4 4600                   BNE         L7024:8
  000002C6 1A80                   SUB.L       ER0,ER0
  000002C8 F80B                   MOV.B       #H'0B:8,R0L
  000002CA 01006BA000000000       MOV.L       ER0,@__$y$23:32
  000002D2 1B71                   DEC.L       #1,ER1
  000002D4 01006BA100000000       MOV.L       ER1,@__$z$24:32
  000002DC 7A290010               CMP.L       #H'0010:16,ER1
  000002E0 4400                   BHS         L7023:8
  000002E2 5470                   RTS
       258:            }
       259:        }
       260:    }
       261:    
       262:    // --------------------------------------------------------------------
       263:    // TFT LCD バックライト消灯
       264:    // --------------------------------------------------------------------
       265:    void LCD_FadeOUT(void)
  000002E4                    _LCD_FadeOUT:                        ; function: LCD_FadeOUT
  000002E4 01006DF2               PUSH.L      ER2
       266:    {
       267:        static unsigned long y, z;
       268:        
       269:        for(z = 0x10; z <= 0x2579; z ++ )
  000002E8 7A0A256A               MOV.L       #H'256A:16,ER2
  000002EC 79010010               MOV.W       #H'0010:16,R1
  000002F0                    L7028:                                
       270:        {
       271:            for(y = 0; y <= 100; y ++ )
  000002F0 F865                   MOV.B       #H'65:8,R0L
  000002F2                    L7029:                                
       272:            {
       273:                TPU4.TGRB = z & 0xFFFF;
  000002F2 6B81FEEA               MOV.W       R1,@H'00FFFEEA:16
  000002F6 1A08                   DEC.B       R0L
  000002F8 4600                   BNE         L7029:8
  000002FA 1A80                   SUB.L       ER0,ER0
  000002FC F865                   MOV.B       #H'65:8,R0L
  000002FE 01006BA000000000       MOV.L       ER0,@__$y$27:32
  00000306 0B51                   INC.W       #1,R1
  00000308 1B72                   DEC.L       #1,ER2
  0000030A 4600                   BNE         L7028:8
  0000030C 7A7C257A48000000       MOV.L       #H'257A:16,@__$z$28:32
           0000               
  00000316 5402                   RTS/L       ER2
       274:            }
       275:        }
       276:    }
       277:    
       278:    // --------------------------------------------------------------------
       279:    // FONTデータ展開(Flash→内部RAM)
       280:    // --------------------------------------------------------------------
       281:    void FONT_open(void)
  00000318                    _FONT_open:                          ; function: FONT_open
  00000318 01106DF2               STM.L       (ER2-ER3),@-SP
       282:    {
       283:        static unsigned long icnt;
       284:        
       285:        for(icnt = 0; icnt < 0x00012C00; icnt ++ )
  0000031C 7A0300012C00           MOV.L       #H'00012C00,ER3
  00000322 0FB2                   MOV.L       ER3,ER2
       286:        {
       287:            *(FONTR + icnt) = *(FONT + icnt) & 0xF800;  // 白文字→赤文字で転送
  00000324 1A91                   SUB.L       ER1,ER1
  00000326                    L7034:                                
  00000326 78106B200000F800       MOV.W       @(H'0000F800:32,ER1),R0
  0000032E 7960F800               AND.W       #H'F800:16,R0
  00000332 78106BA00024B000       MOV.W       R0,@(H'0024B000:32,ER1)
  0000033A 0BF1                   INC.L       #2,ER1
  0000033C 1B72                   DEC.L       #1,ER2
  0000033E 4600                   BNE         L7034:8
  00000340 01006BA300000000       MOV.L       ER3,@__$icnt$31:32
  00000348 5413                   RTS/L       (ER2-ER3)
       288:    //      *(FONTR + icnt) = *(FONT + icnt) & 0x07E0;  // 白文字→緑文字で転送
       289:    //      *(FONTR + icnt) = *(FONT + icnt) & 0x001F;  // 白文字→青文字で転送
       290:        }
       291:    }
       292:    
       293:    /*
       294:    // --------------------------------------------------------------------
       295:    // TFT LCD 点描画
       296:    // --------------------------------------------------------------------
       297:    void LCD_pset(unsigned int x, unsigned int y, unsigned int color)
       298:    {
       299:        unsigned long z;
       300:        
       301:        z = y;
       302:        
       303:        if(g_drawbuff_flg)
       304:        {
       305:            *(ADATA + (x + z * 320)) = color;
       306:        }
       307:        else
       308:        {
       309:            *(BDATA + (x + z * 320)) = color;
       310:        }
       311:    }
       312:    */
       313:    
       314:    // --------------------------------------------------------------------
       315:    // TFT LCD 線描画
       316:    // --------------------------------------------------------------------
       317:    void LCD_line(unsigned int x0, unsigned int y0, unsigned int x1, unsigned int y1, unsigned int color)
  0000034A                    _LCD_line:                           ; function: LCD_line
  0000034A 01306DF2               STM.L       (ER2-ER5),@-SP
  0000034E 01006DF6               PUSH.L      ER6
  00000352 79370008               SUB.W       #8:16,R7
       318:    {
       319:        unsigned int st;
       320:        int sx0, sx1, sy0, sy1;
       321:        int dx, dy;
       322:        int err;
       323:        int ystep;
       324:        unsigned long x, y;
       325:        
       326:        sx0 = (int) x0;
  00000356 69F0                   MOV.W       R0,@SP
       327:        sx1 = (int) x1;
  00000358 6FF10004               MOV.W       R1,@(4:16,SP)
       328:        sy0 = (int) y0;
  0000035C 6FF80002               MOV.W       E0,@(2:16,SP)
       329:        sy1 = (int) y1;
  00000360 6FF90006               MOV.W       E1,@(6:16,SP)
       330:        
       331:        st = abs(sy1 - sy0) > abs(sx1 - sx0);
  00000364 1989                   SUB.W       E0,E1
  00000366 0D90                   MOV.W       E1,R0
  00000368 7A0300000000           MOV.L       #_abs,ER3
  0000036E 5D30                   JSR         @ER3
  00000370 0D02                   MOV.W       R0,R2
  00000372 6F700004               MOV.W       @(4:16,SP),R0
  00000376 7CF01900               SUB.W       @SP,R0
  0000037A 5D30                   JSR         @ER3
  0000037C 1988                   SUB.W       E0,E0
  0000037E 1D02                   CMP.W       R0,R2
  00000380 4F00                   BLE         L7039:8
  00000382 0F18                   MOV.W       #1:3,E0
  00000384                    L7039:                                
  00000384 0D84                   MOV.W       E0,R4
  00000386 4700                   BEQ         L7041:8
       332:        
       333:        if(st)
       334:        {
       335:            swap(&sx0, &sy0);
  00000388 0FF0                   MOV.L       SP,ER0
  0000038A 0FF1                   MOV.L       SP,ER1
  0000038C 0BF1                   INC.L       #2,ER1
  0000038E 5E000000               JSR         @_swap:24
       336:            swap(&sx1, &sy1);
  00000392 0FF0                   MOV.L       SP,ER0
  00000394 0B90                   ADDS.L      #4,ER0
  00000396 0FF1                   MOV.L       SP,ER1
  00000398 0A61                   ADD.W       #6:3,R1
  0000039A 5E000000               JSR         @_swap:24
  0000039E                    L7041:                                
       337:        }
       338:        
       339:        if(sx0 > sx1)
  0000039E 0156697C0720           CMP.W       @(4:2,SP),@SP
  000003A4 4F00                   BLE         L7043:8
       340:        {
       341:            swap(&sx0, &sx1);
  000003A6 0FF0                   MOV.L       SP,ER0
  000003A8 0FF1                   MOV.L       SP,ER1
  000003AA 0B91                   ADDS.L      #4,ER1
  000003AC 5E000000               JSR         @_swap:24
       342:            swap(&sy0, &sy1);
  000003B0 0FF0                   MOV.L       SP,ER0
  000003B2 0BF0                   INC.L       #2,ER0
  000003B4 0FF1                   MOV.L       SP,ER1
  000003B6 0A61                   ADD.W       #6:3,R1
  000003B8 5E000000               JSR         @_swap:24
  000003BC                    L7043:                                
       343:        }
       344:        
       345:        dx = sx1 - sx0;
  000003BC 6F720004               MOV.W       @(4:16,SP),R2
  000003C0 7CF01902               SUB.W       @SP,R2
  000003C4 0D2D                   MOV.W       R2,E5
       346:        dy = abs(sy1 - sy0);
  000003C6 6F700006               MOV.W       @(6:16,SP),R0
  000003CA 015A1730               SUB.W       @(2:2,SP),R0
  000003CE 5D30                   JSR         @ER3
  000003D0 0D0A                   MOV.W       R0,E2
       347:        err = dx >> 1;
  000003D2 1192                   SHAR.W      R2
       348:        ystep = (sy0 < sy1)? +1 : -1;
  000003D4 6F700002               MOV.W       @(2:16,SP),R0
  000003D8 790CFFFF               MOV.W       #H'FFFF:16,E4
  000003DC 015A3720               CMP.W       @(6:2,SP),R0
  000003E0 4C00                   BGE         L7045:8
  000003E2 0F1C                   MOV.W       #1:3,E4
  000003E4                    L7045:                                
       349:        y = sy0;
  000003E4 17F0                   EXTS.L      ER0
  000003E6 0F83                   MOV.L       ER0,ER3
       350:        
       351:        for(x = sx0; x <= sx1; x++)
  000003E8 6971                   MOV.W       @SP,R1
  000003EA 17F1                   EXTS.L      ER1
  000003EC 179A                   NEG.W       E2
  000003EE 0DA5                   MOV.W       E2,R5
  000003F0 0DC0                   MOV.W       E4,R0
  000003F2 17F0                   EXTS.L      ER0
  000003F4 0F86                   MOV.L       ER0,ER6
  000003F6 5A000000               JMP         @L7046:24
  000003FA                    L7047:                                
       352:        {
       353:            if(st)
  000003FA 0D44                   MOV.W       R4,R4
  000003FC 4700                   BEQ         L7049:8
       354:            {
       355:                if((y >= 0) && (x >= 0) && (y < 320) && (x < 240))
  000003FE 7A2B0140               CMP.L       #H'0140:16,ER3
  00000402 58400000               BHS         L7051:16
  00000406 7A2900F0               CMP.L       #H'00F0:16,ER1
  0000040A 4400                   BHS         L7051:8
       356:                {
       357:                    if(g_drawbuff_flg)
  0000040C 0F90                   MOV.L       ER1,ER0
  0000040E 1070                   SHLL.L      #2,ER0
  00000410 0A90                   ADD.L       ER1,ER0
  00000412 03861030               SHLL.L      #6:5,ER0
  00000416 0AB0                   ADD.L       ER3,ER0
  00000418 1030                   SHLL.L      ER0
  0000041A 6B2A00000000           MOV.W       @_g_drawbuff_flg:32,E2
  00000420 4700                   BEQ         L7054:8
       358:                    {
       359:                        *(ADATA + (y + x * 320)) = color;
  00000422 0158C7C800200020       MOV.W       @(H'0020:16,SP),@(H'00200000:32,ER0)
           0000               
  0000042C 4000                   BRA         L7051:8
  0000042E                    L7054:                                
       360:                    }
       361:                    else
       362:                    {
       363:                        *(BDATA + (y + x * 320)) = color;
  0000042E 0158C7C800200022       MOV.W       @(H'0020:16,SP),@(H'00225800:32,ER0)
           5800               
  00000438 4000                   BRA         L7051:8
  0000043A                    L7049:                                
       364:                    }
       365:                }
       366:            }
       367:            else
       368:            {
       369:                if((x >= 0) && (y >= 0) && (x < 320) && (y < 240))
  0000043A 7A290140               CMP.L       #H'0140:16,ER1
  0000043E 4400                   BHS         L7051:8
  00000440 7A2B00F0               CMP.L       #H'00F0:16,ER3
  00000444 4400                   BHS         L7051:8
       370:                {
       371:                    if(g_drawbuff_flg)
  00000446 0FB0                   MOV.L       ER3,ER0
  00000448 1070                   SHLL.L      #2,ER0
  0000044A 0AB0                   ADD.L       ER3,ER0
  0000044C 03861030               SHLL.L      #6:5,ER0
  00000450 0A90                   ADD.L       ER1,ER0
  00000452 1030                   SHLL.L      ER0
  00000454 6B2A00000000           MOV.W       @_g_drawbuff_flg:32,E2
  0000045A 4700                   BEQ         L7058:8
       372:                    {
       373:                        *(ADATA + (x + y * 320)) = color;
  0000045C 0158C7C800200020       MOV.W       @(H'0020:16,SP),@(H'00200000:32,ER0)
           0000               
  00000466 4000                   BRA         L7051:8
  00000468                    L7058:                                
       374:                    }
       375:                    else
       376:                    {
       377:                        *(BDATA + (x + y * 320)) = color;
  00000468 0158C7C800200022       MOV.W       @(H'0020:16,SP),@(H'00225800:32,ER0)
           5800               
  00000472                    L7051:                                
       378:                    }
       379:                }
       380:            }
       381:            
       382:            err = err - dy;
  00000472 0952                   ADD.W       R5,R2
       383:            if(err < 0)
  00000474 0D22                   MOV.W       R2,R2
  00000476 4C00                   BGE         L7060:8
       384:            {
       385:                y = y + ystep;
  00000478 0AE3                   ADD.L       ER6,ER3
       386:                err = err + dx;
  0000047A 09D2                   ADD.W       E5,R2
  0000047C                    L7060:                                
  0000047C 0B71                   INC.L       #1,ER1
  0000047E                    L7046:                                
  0000047E 6F700004               MOV.W       @(4:16,SP),R0
  00000482 17F0                   EXTS.L      ER0
  00000484 1F81                   CMP.L       ER0,ER1
  00000486 58300000               BLS         L7047:16
  0000048A 79170008               ADD.W       #8:16,R7
  0000048E 01006D76               POP.L       ER6
  00000492 5435                   RTS/L       (ER2-ER5)
       387:            }
       388:        }
       389:    }
       390:    
       391:    // --------------------------------------------------------------------
       392:    // TFT LCD 線描画 2倍寸
       393:    // --------------------------------------------------------------------
       394:    void LCD_line2(unsigned int x0, unsigned int y0, unsigned int x1, unsigned int y1, unsigned int color)
  00000494                    _LCD_line2:                          ; function: LCD_line2
  00000494 01306DF2               STM.L       (ER2-ER5),@-SP
  00000498 01006DF6               PUSH.L      ER6
  0000049C 79370010               SUB.W       #H'0010:16,R7
       395:    {
       396:        unsigned int st;
       397:        int sx0, sx1, sy0, sy1;
       398:        int dx, dy;
       399:        int err;
       400:        int ystep;
       401:        unsigned long x, y;
       402:        
       403:        sx0 = (int) x0;
  000004A0 69F0                   MOV.W       R0,@SP
       404:        sx1 = (int) x1;
  000004A2 6FF10004               MOV.W       R1,@(4:16,SP)
       405:        sy0 = (int) y0;
  000004A6 6FF80002               MOV.W       E0,@(2:16,SP)
       406:        sy1 = (int) y1;
  000004AA 6FF90006               MOV.W       E1,@(6:16,SP)
       407:        
       408:        st = abs(sy1 - sy0) > abs(sx1 - sx0);
  000004AE 1989                   SUB.W       E0,E1
  000004B0 0D90                   MOV.W       E1,R0
  000004B2 7A0300000000           MOV.L       #_abs,ER3
  000004B8 5D30                   JSR         @ER3
  000004BA 0D02                   MOV.W       R0,R2
  000004BC 6F700004               MOV.W       @(4:16,SP),R0
  000004C0 7CF01900               SUB.W       @SP,R0
  000004C4 5D30                   JSR         @ER3
  000004C6 1988                   SUB.W       E0,E0
  000004C8 1D02                   CMP.W       R0,R2
  000004CA 4F00                   BLE         L7064:8
  000004CC 0F18                   MOV.W       #1:3,E0
  000004CE                    L7064:                                
  000004CE 0D8C                   MOV.W       E0,E4
  000004D0 4700                   BEQ         L7066:8
       409:        
       410:        if(st)
       411:        {
       412:            swap(&sx0, &sy0);
  000004D2 0FF0                   MOV.L       SP,ER0
  000004D4 0FF1                   MOV.L       SP,ER1
  000004D6 0BF1                   INC.L       #2,ER1
  000004D8 5E000000               JSR         @_swap:24
       413:            swap(&sx1, &sy1);
  000004DC 0FF0                   MOV.L       SP,ER0
  000004DE 0B90                   ADDS.L      #4,ER0
  000004E0 0FF1                   MOV.L       SP,ER1
  000004E2 0A61                   ADD.W       #6:3,R1
  000004E4 5E000000               JSR         @_swap:24
  000004E8                    L7066:                                
       414:        }
       415:        
       416:        if(sx0 > sx1)
  000004E8 0156697C0720           CMP.W       @(4:2,SP),@SP
  000004EE 4F00                   BLE         L7068:8
       417:        {
       418:            swap(&sx0, &sx1);
  000004F0 0FF0                   MOV.L       SP,ER0
  000004F2 0FF1                   MOV.L       SP,ER1
  000004F4 0B91                   ADDS.L      #4,ER1
  000004F6 5E000000               JSR         @_swap:24
       419:            swap(&sy0, &sy1);
  000004FA 0FF0                   MOV.L       SP,ER0
  000004FC 0BF0                   INC.L       #2,ER0
  000004FE 0FF1                   MOV.L       SP,ER1
  00000500 0A61                   ADD.W       #6:3,R1
  00000502 5E000000               JSR         @_swap:24
  00000506                    L7068:                                
       420:        }
       421:        
       422:        dx = sx1 - sx0;
  00000506 6F740004               MOV.W       @(4:16,SP),R4
  0000050A 7CF01904               SUB.W       @SP,R4
  0000050E 6FF40008               MOV.W       R4,@(8:16,SP)
       423:        dy = abs(sy1 - sy0);
  00000512 6F700006               MOV.W       @(6:16,SP),R0
  00000516 015A1730               SUB.W       @(2:2,SP),R0
  0000051A 5D30                   JSR         @ER3
  0000051C 0D0A                   MOV.W       R0,E2
       424:        err = dx >> 1;
  0000051E 1194                   SHAR.W      R4
       425:        ystep = (sy0 < sy1)? +1 : -1;
  00000520 6F710002               MOV.W       @(2:16,SP),R1
  00000524 7902FFFF               MOV.W       #H'FFFF:16,R2
  00000528 015A3721               CMP.W       @(6:2,SP),R1
  0000052C 4C00                   BGE         L7070:8
  0000052E 0F12                   MOV.W       #1:3,R2
  00000530                    L7070:                                
       426:        y = sy0;
  00000530 17F1                   EXTS.L      ER1
       427:        
       428:        for(x = sx0; x < sx1; x++)
  00000532 6970                   MOV.W       @SP,R0
  00000534 17F0                   EXTS.L      ER0
  00000536 0F83                   MOV.L       ER0,ER3
  00000538 179A                   NEG.W       E2
  0000053A 6FFA000A               MOV.W       E2,@(H'000A:16,SP)
  0000053E 0D20                   MOV.W       R2,R0
  00000540 17F0                   EXTS.L      ER0
  00000542 010369F0               MOV.L       ER0,@(12:2,SP)
  00000546 5A000000               JMP         @L7071:24
  0000054A                    L7072:                                
       429:        {
       430:            if(st)
  0000054A 0DCC                   MOV.W       E4,E4
  0000054C 58700000               BEQ         L7074:16
       431:            {
       432:                if((y >= 0) && (x >= 0) && (y < 320) && (x < 240))
  00000550 7A290140               CMP.L       #H'0140:16,ER1
  00000554 58400000               BHS         L7076:16
  00000558 7A2B00F0               CMP.L       #H'00F0:16,ER3
  0000055C 58400000               BHS         L7076:16
       433:                {
       434:                    if(g_drawbuff_flg)
  00000560 0FB2                   MOV.L       ER3,ER2
  00000562 1072                   SHLL.L      #2,ER2
  00000564 0AB2                   ADD.L       ER3,ER2
  00000566 03861032               SHLL.L      #6:5,ER2
  0000056A 0F95                   MOV.L       ER1,ER5
  0000056C 0AA5                   ADD.L       ER2,ER5
  0000056E 1035                   SHLL.L      ER5
  00000570 0F96                   MOV.L       ER1,ER6
  00000572 1B76                   DEC.L       #1,ER6
  00000574 0AA6                   ADD.L       ER2,ER6
  00000576 1036                   SHLL.L      ER6
  00000578 0FB0                   MOV.L       ER3,ER0
  0000057A 1A98                   SUB.L       #1:3,ER0
  0000057C 0F82                   MOV.L       ER0,ER2
  0000057E 1070                   SHLL.L      #2,ER0
  00000580 0A82                   ADD.L       ER0,ER2
  00000582 03861032               SHLL.L      #6:5,ER2
  00000586 0A92                   ADD.L       ER1,ER2
  00000588 1032                   SHLL.L      ER2
  0000058A 6B2000000000           MOV.W       @_g_drawbuff_flg:32,R0
  00000590 4700                   BEQ         L7079:8
       435:                    {
       436:                        *(ADATA + (y + x       * 320)) = color;
  00000592 6F700028               MOV.W       @(H'0028:16,SP),R0
  00000596 78506BA000200000       MOV.W       R0,@(H'00200000:32,ER5)
       437:                        *(ADATA + ((y - 1) + x * 320)) = color;
  0000059E 78606BA000200000       MOV.W       R0,@(H'00200000:32,ER6)
       438:                        *(ADATA + ((y + 1) + x * 320)) = color;
  000005A6 78506BA000200002       MOV.W       R0,@(H'00200002:32,ER5)
       439:                        *(ADATA + (y + (x - 1) * 320)) = color;
  000005AE 78206BA000200000       MOV.W       R0,@(H'00200000:32,ER2)
       440:                        *(ADATA + (y + (x + 1) * 320)) = color;
  000005B6 78506BA000200280       MOV.W       R0,@(H'00200280:32,ER5)
  000005BE 5A000000               JMP         @L7076:24
  000005C2                    L7079:                                
       441:                    }
       442:                    else
       443:                    {
       444:                        *(BDATA + (y + x       * 320)) = color;
  000005C2 6F700028               MOV.W       @(H'0028:16,SP),R0
  000005C6 78506BA000225800       MOV.W       R0,@(H'00225800:32,ER5)
       445:                        *(BDATA + ((y - 1) + x * 320)) = color;
  000005CE 78606BA000225800       MOV.W       R0,@(H'00225800:32,ER6)
       446:                        *(BDATA + ((y + 1) + x * 320)) = color;
  000005D6 78506BA000225802       MOV.W       R0,@(H'00225802:32,ER5)
       447:                        *(BDATA + (y + (x - 1) * 320)) = color;
  000005DE 78206BA000225800       MOV.W       R0,@(H'00225800:32,ER2)
       448:                        *(BDATA + (y + (x + 1) * 320)) = color;
  000005E6 78506BA000225A80       MOV.W       R0,@(H'00225A80:32,ER5)
  000005EE 5A000000               JMP         @L7076:24
  000005F2                    L7074:                                
       449:                    }
       450:                }
       451:            }
       452:            else
       453:            {
       454:                if((x >= 0) && (y >= 0) && (x < 320) && (y < 240))
  000005F2 7A2B0140               CMP.L       #H'0140:16,ER3
  000005F6 58400000               BHS         L7076:16
  000005FA 7A2900F0               CMP.L       #H'00F0:16,ER1
  000005FE 58400000               BHS         L7076:16
       455:                {
       456:                    if(g_drawbuff_flg)
  00000602 0F92                   MOV.L       ER1,ER2
  00000604 1072                   SHLL.L      #2,ER2
  00000606 0A92                   ADD.L       ER1,ER2
  00000608 03861032               SHLL.L      #6:5,ER2
  0000060C 0FB6                   MOV.L       ER3,ER6
  0000060E 0AA6                   ADD.L       ER2,ER6
  00000610 1A9E                   SUB.L       #1:3,ER6
  00000612 1036                   SHLL.L      ER6
  00000614 0FB5                   MOV.L       ER3,ER5
  00000616 0AA5                   ADD.L       ER2,ER5
  00000618 1035                   SHLL.L      ER5
  0000061A 0F90                   MOV.L       ER1,ER0
  0000061C 1B70                   DEC.L       #1,ER0
  0000061E 0F82                   MOV.L       ER0,ER2
  00000620 1070                   SHLL.L      #2,ER0
  00000622 0A82                   ADD.L       ER0,ER2
  00000624 03861032               SHLL.L      #6:5,ER2
  00000628 0AB2                   ADD.L       ER3,ER2
  0000062A 1032                   SHLL.L      ER2
  0000062C 6B2000000000           MOV.W       @_g_drawbuff_flg:32,R0
  00000632 4700                   BEQ         L7083:8
       457:                    {
       458:                        *(ADATA + (x + y       * 320)) = color;
  00000634 6F700028               MOV.W       @(H'0028:16,SP),R0
  00000638 78506BA000200000       MOV.W       R0,@(H'00200000:32,ER5)
       459:                        *(ADATA + ((x - 1) + y * 320)) = color;
  00000640 78606BA000200000       MOV.W       R0,@(H'00200000:32,ER6)
       460:                        *(ADATA + ((x + 1) + y * 320)) = color;
  00000648 78506BA000200002       MOV.W       R0,@(H'00200002:32,ER5)
       461:                        *(ADATA + (x + (y - 1) * 320)) = color;
  00000650 78206BA000200000       MOV.W       R0,@(H'00200000:32,ER2)
       462:                        *(ADATA + (x + (y + 1) * 320)) = color;
  00000658 78506BA000200280       MOV.W       R0,@(H'00200280:32,ER5)
  00000660 4000                   BRA         L7076:8
  00000662                    L7083:                                
       463:                    }
       464:                    else
       465:                    {
       466:                        *(BDATA + (x + y       * 320)) = color;
  00000662 6F700028               MOV.W       @(H'0028:16,SP),R0
  00000666 78506BA000225800       MOV.W       R0,@(H'00225800:32,ER5)
       467:                        *(BDATA + ((x - 1) + y * 320)) = color;
  0000066E 78606BA000225800       MOV.W       R0,@(H'00225800:32,ER6)
       468:                        *(BDATA + ((x + 1) + y * 320)) = color;
  00000676 78506BA000225802       MOV.W       R0,@(H'00225802:32,ER5)
       469:                        *(BDATA + (x + (y - 1) * 320)) = color;
  0000067E 78206BA000225800       MOV.W       R0,@(H'00225800:32,ER2)
       470:                        *(BDATA + (x + (y + 1) * 320)) = color;
  00000686 78506BA000225A80       MOV.W       R0,@(H'00225A80:32,ER5)
  0000068E                    L7076:                                
       471:                    }
       472:                }
       473:            }
       474:            
       475:            err = err - dy;
  0000068E 015AC714000A           ADD.W       @(H'000A:16,SP),R4
       476:            if(err < 0)
  00000694 0D44                   MOV.W       R4,R4
  00000696 4C00                   BGE         L7085:8
       477:            {
       478:                y = y + ystep;
  00000698 010A3711               ADD.L       @(12:2,SP),ER1
       479:                err = err + dx;
  0000069C 015AC7140008           ADD.W       @(8:16,SP),R4
  000006A2                    L7085:                                
  000006A2 0B73                   INC.L       #1,ER3
  000006A4                    L7071:                                
  000006A4 6F700004               MOV.W       @(4:16,SP),R0
  000006A8 17F0                   EXTS.L      ER0
  000006AA 1F83                   CMP.L       ER0,ER3
  000006AC 58500000               BLO         L7072:16
  000006B0 79170010               ADD.W       #H'0010:16,R7
  000006B4 01006D76               POP.L       ER6
  000006B8 5435                   RTS/L       (ER2-ER5)
       480:            }
       481:        }
       482:    }
       483:    
       484:    void swap(int *x0, int *x1)
  000006BA                    _swap:                               ; function: swap
  000006BA 01006DF2               PUSH.L      ER2
       485:    {
       486:        int temp;
       487:        temp = *x0;
  000006BE 0F82                   MOV.L       ER0,ER2
  000006C0 6908                   MOV.W       @ER0,E0
       488:        *x0 = *x1;
  000006C2 01580102               MOV.W       @ER1,@ER2
       489:        *x1 = temp;
  000006C6 6998                   MOV.W       E0,@ER1
  000006C8 5402                   RTS/L       ER2
       490:    }
       491:    
       492:    /*
       493:    // --------------------------------------------------------------------
       494:    // TFT LCD 画面クリア(ソフトウェア転送版)
       495:    // --------------------------------------------------------------------
       496:    void LCD_CLR(unsigned int color)
       497:    {
       498:        static unsigned long icnt;
       499:        
       500:        for(icnt = 0; icnt < 0x00012C00; icnt ++ )
       501:        {
       502:            if(g_drawbuff_flg)
       503:            {
       504:                *(ADATA + icnt) = color;
       505:            }
       506:            else
       507:            {
       508:                *(BDATA + icnt) = color;
       509:            }
       510:        }
       511:    }
       512:    */
       513:    
       514:    // --------------------------------------------------------------------
       515:    // TFT LCD 画面クリア(ハードウェアDMA1転送版)
       516:    // --------------------------------------------------------------------
       517:    void LCD_CLR(unsigned int color)
  000006CA                    _LCD_CLR:                            ; function: LCD_CLR
  000006CA 1B87                   SUBS.L      #2,SP
       518:    {
       519:        unsigned int    *color_p;
       520:        color_p = &color;
       521:        
       522:        DMAC1.DTCR = 0x00012C00 * 2;
  000006CC 69F0                   MOV.W       R0,@SP
  000006CE 01580707               MOV.W       @SP,@SP
  000006D2 7A74000258004000       MOV.L       #H'00025800:32,@H'00FFFC2C:16
           FC2C               
       523:        DMAC1.DSAR = color_p;
  000006DC 01006B87FC20           MOV.L       SP,@H'00FFFC20:16
       524:        if(g_drawbuff_flg)
  000006E2 6B2100000000           MOV.W       @_g_drawbuff_flg:32,R1
  000006E8 4700                   BEQ         L7091:8
       525:        {
       526:            DMAC1.DDAR = ADATA;
  000006EA 7A74002000004000       MOV.L       #H'00200000:32,@H'00FFFC24:16
           FC24               
  000006F4 4000                   BRA         L7092:8
  000006F6                    L7091:                                
       527:        }
       528:        else
       529:        {
       530:            DMAC1.DDAR = BDATA;
  000006F6 7A74002258004000       MOV.L       #H'00225800:32,@H'00FFFC24:16
           FC24               
  00000700                    L7092:                                
       531:        }
       532:        DMAC1.DMDR.BIT.DTE  = 1;
  00000700 6A18FC347070           BSET.B      #7,@H'00FFFC34:16
  00000706                    L7093:                                
       533:        while(DMAC1.DMDR.BIT.DTIF == 0);
  00000706 6A08FC35               MOV.B       @H'00FFFC35:16,R0L
  0000070A 7708                   BLD.B       #0,R0L
  0000070C 4400                   BCC         L7093:8
  0000070E 0BF7                   INC.L       #2,SP
  00000710 5470                   RTS
       534:    }
       535:    
       536:    /*
       537:    // --------------------------------------------------------------------
       538:    // TFT LCD 画面塗りつぶし(ソフトウェア転送版)
       539:    // --------------------------------------------------------------------
       540:    void LCD_PAINT(unsigned int x, unsigned int y, unsigned int w, unsigned int h, unsigned int color)
       541:    {
       542:        unsigned long   i, j;
       543:        
       544:        for(j = 0; j < h; j++)
       545:        {
       546:            for(i = 0; i < w; i++)
       547:            {
       548:                if(g_drawbuff_flg)
       549:                {
       550:                    *(ADATA + ((x + i) + (y + j) * 320)) = color;
       551:                }
       552:                else
       553:                {
       554:                    *(BDATA + ((x + i) + (y + j) * 320)) = color;
       555:                }
       556:            }
       557:        }
       558:    }
       559:    */
       560:    
       561:    // --------------------------------------------------------------------
       562:    // TFT LCD 画面塗りつぶし(ハードウェアDMA1転送版)
       563:    // --------------------------------------------------------------------
       564:    void LCD_PAINT(unsigned int x, unsigned int y, unsigned int w, unsigned int h, unsigned int color)
  00000712                    _LCD_PAINT:                          ; function: LCD_PAINT
  00000712 01306DF2               STM.L       (ER2-ER5),@-SP
  00000716 01006DF6               PUSH.L      ER6
  0000071A 1B97                   SUBS.L      #4,SP
       565:    {
       566:        unsigned long   j;
       567:        unsigned int    *color_p;
       568:        color_p = &color;
  0000071C 0D1B                   MOV.W       R1,E3
  0000071E 6FF80002               MOV.W       E0,@(2:16,SP)
  00000722 69F0                   MOV.W       R0,@SP
  00000724 0FF4                   MOV.L       SP,ER4
  00000726 7914001C               ADD.W       #H'001C:16,R4
       569:        
       570:        for(j = 0; j < h; j++)
  0000072A 1AA2                   SUB.L       ER2,ER2
  0000072C 0D91                   MOV.W       E1,R1
  0000072E 1771                   EXTU.L      ER1
  00000730 0F95                   MOV.L       ER1,ER5
  00000732 0DB1                   MOV.W       E3,R1
  00000734 1011                   SHLL.W      R1
  00000736 1771                   EXTU.L      ER1
  00000738 0F96                   MOV.L       ER1,ER6
       571:        {
       572:            DMAC1.DTCR = w * 2;
       573:            DMAC1.DSAR = color_p;
       574:            if(g_drawbuff_flg)
       575:            {
       576:                DMAC1.DDAR = (ADATA + ((x) + (y + j) * 320));
       577:            }
       578:            else
       579:            {
       580:                DMAC1.DDAR = (BDATA + ((x) + (y + j) * 320));
  0000073A 0D81                   MOV.W       E0,R1
  0000073C 79080140               MOV.W       #H'0140:16,E0
  00000740 5281                   MULXU.W     E0,ER1
  00000742 1770                   EXTU.L      ER0
  00000744 4001                   BRA/S       L7096:8
  00000746 0F93                   MOV.L       ER1,ER3
  00000748                    L7097:                                
  00000748 01006B86FC2C           MOV.L       ER6,@H'00FFFC2C:16
  0000074E 01006B84FC20           MOV.L       ER4,@H'00FFFC20:16
  00000754 0FA9                   MOV.L       #2:3,ER1
  00000756 0FB0                   MOV.L       ER3,ER0
  00000758 01CA5210               MULU.L      ER1,ER0
  0000075C 6B2100000000           MOV.W       @_g_drawbuff_flg:32,R1
  00000762 4700                   BEQ         L7099:8
  00000764 7A1000200000           ADD.L       #H'00200000,ER0
  0000076A 4000                   BRA         L7100:8
  0000076C                    L7099:                                
  0000076C 7A1000225800           ADD.L       #H'00225800,ER0
  00000772                    L7100:                                
       581:            }
       582:            DMAC1.DMDR.BIT.DTE  = 1;
  00000772 01006B80FC24           MOV.L       ER0,@H'00FFFC24:16
  00000778 6A18FC347070           BSET.B      #7,@H'00FFFC34:16
  0000077E                    L7101:                                
       583:            while(DMAC1.DMDR.BIT.DTIF == 0);
  0000077E 6A08FC35               MOV.B       @H'00FFFC35:16,R0L
  00000782 7708                   BLD.B       #0,R0L
  00000784 4400                   BCC         L7101:8
  00000786 0B72                   INC.L       #1,ER2
  00000788 7A080140               MOV.L       #H'0140:16,ER0
  0000078C                    L7096:                                
  0000078C 0A83                   ADD.L       ER0,ER3
  0000078E 1FD2                   CMP.L       ER5,ER2
  00000790 4500                   BLO         L7097:8
  00000792 0B97                   ADDS.L      #4,SP
  00000794 01006D76               POP.L       ER6
  00000798 5435                   RTS/L       (ER2-ER5)
       584:        }
       585:    }
       586:    
       587:    /*
       588:    // --------------------------------------------------------------------
       589:    // TFT LCD 画像コピー描画(ソフトウェア転送版)
       590:    // --------------------------------------------------------------------
       591:    void LCD_Gcopy(unsigned int p, unsigned int q, unsigned int w, unsigned int h, volatile unsigned int *sorce)
       592:    {
       593:        unsigned long   i, j;
       594:        
       595:        for(j = 0; j < h; j++)
       596:        {
       597:            for(i = 0; i < w; i++)
       598:            {
       599:                if(g_drawbuff_flg)
       600:                {
       601:                    *(ADATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320)) = *(sorce + ((p + i) + (q + j) * 320));
       602:                }
       603:                else
       604:                {
       605:                    *(BDATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320)) = *(sorce + ((p + i) + (q + j) * 320));
       606:                }
       607:            }
       608:        }
       609:    }
       610:    */
       611:    
       612:    // --------------------------------------------------------------------
       613:    // TFT LCD 画像コピー描画(ハードウェアDMA0転送版)
       614:    // --------------------------------------------------------------------
       615:    void LCD_Gcopy(unsigned int p, unsigned int q, unsigned int w, unsigned int h, volatile unsigned int *sorce)
  0000079A                    _LCD_Gcopy:                          ; function: LCD_Gcopy
  0000079A 01306DF2               STM.L       (ER2-ER5),@-SP
  0000079E 01006DF6               PUSH.L      ER6
       616:    {
       617:        unsigned long   j;
       618:        
       619:        for(j = 0; j < h; j++)
  000007A2 0D1C                   MOV.W       R1,E4
  000007A4 0D04                   MOV.W       R0,R4
  000007A6 1AA2                   SUB.L       ER2,ER2
  000007A8 0D91                   MOV.W       E1,R1
  000007AA 1771                   EXTU.L      ER1
  000007AC 0F95                   MOV.L       ER1,ER5
  000007AE 79010140               MOV.W       #H'0140:16,R1
  000007B2 0D80                   MOV.W       E0,R0
  000007B4 5210                   MULXU.W     R1,ER0
  000007B6 0D41                   MOV.W       R4,R1
  000007B8 1771                   EXTU.L      ER1
  000007BA 0F86                   MOV.L       ER0,ER6
  000007BC 0A96                   ADD.L       ER1,ER6
  000007BE 101C                   SHLL.W      E4
  000007C0 0DC0                   MOV.W       E4,R0
  000007C2 1770                   EXTU.L      ER0
  000007C4 0F83                   MOV.L       ER0,ER3
  000007C6 5A000000               JMP         @L7105:24
  000007CA                    L7106:                                
       620:        {
       621:            DMAC0.DTCR = w * 2;
  000007CA 01006B83FC0C           MOV.L       ER3,@H'00FFFC0C:16
       622:            DMAC0.DSAR = (sorce + ((p) + (q + j) * 320));
  000007D0 0FA0                   MOV.L       ER2,ER0
  000007D2 1070                   SHLL.L      #2,ER0
  000007D4 0AA0                   ADD.L       ER2,ER0
  000007D6 03861030               SHLL.L      #6:5,ER0
  000007DA 0AE0                   ADD.L       ER6,ER0
  000007DC 1030                   SHLL.L      ER0
  000007DE 010AC7100018           ADD.L       @(H'0018:16,SP),ER0
  000007E4 01006B80FC00           MOV.L       ER0,@H'00FFFC00:16
       623:            if(g_drawbuff_flg)
  000007EA 6B2100000000           MOV.W       @_g_drawbuff_flg:32,R1
  000007F0 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  000007F6 1770                   EXTU.L      ER0
  000007F8 0AA0                   ADD.L       ER2,ER0
  000007FA 0D11                   MOV.W       R1,R1
  000007FC 4700                   BEQ         L7108:8
       624:            {
       625:                DMAC0.DDAR = (ADATA + ((g_LCD_x) + (g_LCD_y + j) * 320));
  000007FE 0F81                   MOV.L       ER0,ER1
  00000800 1070                   SHLL.L      #2,ER0
  00000802 0A90                   ADD.L       ER1,ER0
  00000804 03861030               SHLL.L      #6:5,ER0
  00000808 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  0000080E 1771                   EXTU.L      ER1
  00000810 0A90                   ADD.L       ER1,ER0
  00000812 1030                   SHLL.L      ER0
  00000814 7A1000200000           ADD.L       #H'00200000,ER0
  0000081A 4000                   BRA         L7109:8
  0000081C                    L7108:                                
       626:            }
       627:            else
       628:            {
       629:                DMAC0.DDAR = (BDATA + ((g_LCD_x) + (g_LCD_y + j) * 320));
  0000081C 0F81                   MOV.L       ER0,ER1
  0000081E 1070                   SHLL.L      #2,ER0
  00000820 0A90                   ADD.L       ER1,ER0
  00000822 03861030               SHLL.L      #6:5,ER0
  00000826 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  0000082C 1771                   EXTU.L      ER1
  0000082E 0A90                   ADD.L       ER1,ER0
  00000830 1030                   SHLL.L      ER0
  00000832 7A1000225800           ADD.L       #H'00225800,ER0
  00000838                    L7109:                                
       630:            }
       631:            DMAC0.DMDR.BIT.DTE  = 1;
  00000838 01006B80FC04           MOV.L       ER0,@H'00FFFC04:16
  0000083E 6A18FC147070           BSET.B      #7,@H'00FFFC14:16
  00000844                    L7110:                                
       632:            while(DMAC0.DMDR.BIT.DTIF == 0);
  00000844 6A08FC15               MOV.B       @H'00FFFC15:16,R0L
  00000848 7708                   BLD.B       #0,R0L
  0000084A 4400                   BCC         L7110:8
  0000084C 0B72                   INC.L       #1,ER2
  0000084E                    L7105:                                
  0000084E 1FD2                   CMP.L       ER5,ER2
  00000850 58500000               BLO         L7106:16
  00000854 01006D76               POP.L       ER6
  00000858 5435                   RTS/L       (ER2-ER5)
       633:        }
       634:    }
       635:    
       636:    // --------------------------------------------------------------------
       637:    // TFT LCD 文字列出力（小さめ文字）
       638:    // --------------------------------------------------------------------
       639:    void LCD_textout(char chr[])//, unsigned int color)
  0000085A                    _LCD_textout:                        ; function: LCD_textout
  0000085A 01206DF4               STM.L       (ER4-ER6),@-SP
       640:    {
       641:        unsigned int i;
       642:        
       643:        for(i = 0; i <= 32; i++)
  0000085E 0F84                   MOV.L       ER0,ER4
  00000860 1955                   SUB.W       R5,R5
  00000862                    L7114:                                
       644:        {
       645:            if(chr[i] == '\0') return;
  00000862 0D51                   MOV.W       R5,R1
  00000864 1771                   EXTU.L      ER1
  00000866 0F96                   MOV.L       ER1,ER6
  00000868 0AC1                   ADD.L       ER4,ER1
  0000086A 6810                   MOV.B       @ER1,R0H
  0000086C 4700                   BEQ         L7116:8
       646:            LCD_CHR_Copy_Smallfont(chr[i]);         // 単純コピー出力を選択(高速)
  0000086E 0FC0                   MOV.L       ER4,ER0
  00000870 0AE0                   ADD.L       ER6,ER0
  00000872 6808                   MOV.B       @ER0,R0L
  00000874 5500                   BSR         _LCD_CHR_Copy_Smallfont:8
  00000876 0B55                   INC.W       #1,R5
  00000878 79250020               CMP.W       #H'0020:16,R5
  0000087C 4300                   BLS         L7114:8
  0000087E                    L7116:                                
  0000087E 5426                   RTS/L       (ER4-ER6)
       647:    //      LCD_CHR_Alpha_Smallfont(chr[i], color); // 色指定アンチエイリアス出力を選択(低速)
       648:        }
       649:    }
       650:    
       651:    /*
       652:    // --------------------------------------------------------------------
       653:    // TFT LCD 文字単出力（小さめ文字・単純コピー出力）(ソフトウェア転送版)
       654:    // --------------------------------------------------------------------
       655:    void LCD_CHR_Copy_Smallfont(unsigned char chr)
       656:    {
       657:        unsigned long i, j, font_addr;
       658:        
       659:        // フォントテーブルデータの座標の参照先を算出
       660:        font_addr = (((((chr - 0x20) & 0x000000F0) >> 4) * 16) * 320) + ((((chr - 0x20) & 0x0000000F) * 10)) + 46080;
       661:        
       662:        for(j = 0; j < 16; j++)
       663:        {
       664:            for(i = 0; i < 10; i++)
       665:            {
       666:                if(g_drawbuff_flg)
       667:                {
       668:                    (*(ADATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320))) = *(FONT + font_addr + i + j * 320);
       669:                }
       670:                else
       671:                {
       672:                    (*(BDATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320))) = *(FONT + font_addr + i + j * 320);
       673:                }
       674:            }
       675:        }
       676:        g_LCD_x = g_LCD_x  + 10;
       677:    }
       678:    */
       679:    
       680:    // --------------------------------------------------------------------
       681:    // TFT LCD 文字単出力（小さめ文字・単純コピー出力）(ハードウェアDMA0転送版)
       682:    // --------------------------------------------------------------------
       683:    void LCD_CHR_Copy_Smallfont(unsigned char chr)
  00000880                    _LCD_CHR_Copy_Smallfont:             ; function: LCD_CHR_Copy_Smallfont
  00000880 01206DF4               STM.L       (ER4-ER6),@-SP
       684:    {
       685:        unsigned long j, font_addr;
       686:        
       687:        // フォントテーブルデータの座標の参照先を算出
       688:        font_addr = (((((chr - 0x20) & 0x000000F0) >> 4) * 16) * 320) + ((((chr - 0x20) & 0x0000000F) * 10)) + 46080;
       689:        
       690:        for(j = 0; j < 16; j++)
  00000884 1AC4                   SUB.L       ER4,ER4
  00000886 0C89                   MOV.B       R0L,R1L
  00000888 1751                   EXTU.W      R1
  0000088A 79310020               SUB.W       #H'0020:16,R1
  0000088E 0D19                   MOV.W       R1,E1
  00000890 796900F0               AND.W       #H'00F0:16,E1
  00000894 11D9                   SHAR.W      #2,E1
  00000896 11D9                   SHAR.W      #2,E1
  00000898 79001400               MOV.W       #H'1400:16,R0
  0000089C 01C25009               MULS.W      R0,E1
  000008A0 7961000F               AND.W       #H'000F:16,R1
  000008A4 01C650A1               MULS.W      #H'A:4,R1
  000008A8 0919                   ADD.W       R1,E1
  000008AA 0D90                   MOV.W       E1,R0
  000008AC 17F0                   EXTS.L      ER0
  000008AE 7A18B400               ADD.L       #H'B400:16,ER0
  000008B2 1030                   SHLL.L      ER0
  000008B4 7A18F800               ADD.L       #H'F800:16,ER0
  000008B8 0F86                   MOV.L       ER0,ER6
  000008BA 7A0500000000           MOV.L       #_g_LCD_x,ER5
  000008C0                    L7118:                                
       691:        {
       692:            DMAC0.DTCR = 10 * 2;
  000008C0 010D4014FC0C           MOV.L       #H'14:8,@H'00FFFC0C:16
       693:            DMAC0.DSAR = (FONT + font_addr + j * 320);
  000008C6 0FC0                   MOV.L       ER4,ER0
  000008C8 1070                   SHLL.L      #2,ER0
  000008CA 0AC0                   ADD.L       ER4,ER0
  000008CC 03871030               SHLL.L      #7:5,ER0
  000008D0 0AE0                   ADD.L       ER6,ER0
  000008D2 01006B80FC00           MOV.L       ER0,@H'00FFFC00:16
       694:            if(g_drawbuff_flg)
  000008D8 6B2000000000           MOV.W       @_g_drawbuff_flg:32,R0
  000008DE 4700                   BEQ         L7120:8
       695:            {
       696:                DMAC0.DDAR = (ADATA + ((g_LCD_x) + (g_LCD_y + j) * 320));
  000008E0 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  000008E6 1770                   EXTU.L      ER0
  000008E8 0AC0                   ADD.L       ER4,ER0
  000008EA 0F81                   MOV.L       ER0,ER1
  000008EC 1070                   SHLL.L      #2,ER0
  000008EE 0A90                   ADD.L       ER1,ER0
  000008F0 03861030               SHLL.L      #6:5,ER0
  000008F4 6951                   MOV.W       @ER5,R1
  000008F6 1771                   EXTU.L      ER1
  000008F8 0A90                   ADD.L       ER1,ER0
  000008FA 1030                   SHLL.L      ER0
  000008FC 7A1000200000           ADD.L       #H'00200000,ER0
  00000902 4000                   BRA         L7121:8
  00000904                    L7120:                                
       697:            }
       698:            else
       699:            {
       700:                DMAC0.DDAR = (BDATA + ((g_LCD_x) + (g_LCD_y + j) * 320));
  00000904 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  0000090A 1770                   EXTU.L      ER0
  0000090C 0AC0                   ADD.L       ER4,ER0
  0000090E 0F81                   MOV.L       ER0,ER1
  00000910 1070                   SHLL.L      #2,ER0
  00000912 0A90                   ADD.L       ER1,ER0
  00000914 03861030               SHLL.L      #6:5,ER0
  00000918 6951                   MOV.W       @ER5,R1
  0000091A 1771                   EXTU.L      ER1
  0000091C 0A90                   ADD.L       ER1,ER0
  0000091E 1030                   SHLL.L      ER0
  00000920 7A1000225800           ADD.L       #H'00225800,ER0
  00000926                    L7121:                                
       701:            }
       702:            DMAC0.DMDR.BIT.DTE  = 1;
  00000926 01006B80FC04           MOV.L       ER0,@H'00FFFC04:16
  0000092C 6A18FC147070           BSET.B      #7,@H'00FFFC14:16
  00000932                    L7122:                                
       703:            while(DMAC0.DMDR.BIT.DTIF == 0);
  00000932 6A08FC15               MOV.B       @H'00FFFC15:16,R0L
  00000936 7708                   BLD.B       #0,R0L
  00000938 4400                   BCC         L7122:8
  0000093A 0B74                   INC.L       #1,ER4
  0000093C 7A2C0010               CMP.L       #H'0010:16,ER4
  00000940 58500000               BLO         L7118:16
       704:        }
       705:        g_LCD_x = g_LCD_x  + 10;
  00000944 015E0510000A           ADD.W       #H'000A:16,@ER5
  0000094A 5426                   RTS/L       (ER4-ER6)
       706:    }
       707:    
       708:    /*
       709:    // --------------------------------------------------------------------
       710:    // TFT LCD 文字単出力（小さめ文字・色指定アンチエイリアス出力）
       711:    // --------------------------------------------------------------------
       712:    void LCD_CHR_Alpha_Smallfont(unsigned char chr, unsigned int color)
       713:    {
       714:        unsigned long   i, j, font_addr;
       715:        unsigned long   dst_data, font_data;
       716:        unsigned long   rd, gd, bd,rs, gs, bs, alpha;
       717:        
       718:        // フォントテーブルデータの座標の参照先を算出
       719:        font_addr = (((((chr - 0x20) & 0x000000F0) >> 4) * 16) * 320) + ((((chr - 0x20) & 0x0000000F) * 10)) + 46080;
       720:        
       721:        for(j = 0; j < 16; j++)
       722:        {
       723:            for(i = 0; i < 10; i++)
       724:            {
       725:                if(g_drawbuff_flg)
       726:                {
       727:                    dst_data    = (*(ADATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320)));   // 貼り付け先データの該当ピクセルデータの算出
       728:                }
       729:                else
       730:                {
       731:                    dst_data    = (*(BDATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320)));   // 貼り付け先データの該当ピクセルデータの算出
       732:                }
       733:                font_data   = (*(FONT + font_addr + i + j * 320));                      // フォントテーブルデータの該当ピクセルデータの算出(アルファデータ)
       734:                rd          = ((dst_data >> 11) & 0x001F);                              // 貼り付け先データのR要素の算出
       735:                gd          = ((dst_data >>  5) & 0x003F);                              // 貼り付け先データのG要素の算出
       736:                bd          = ((dst_data      ) & 0x001F);                              // 貼り付け先データのB要素の算出
       737:                rs          = ((color         ) & 0x001F);                              // フォント指定色のR要素の算出
       738:                gs          = ((color    >>  5) & 0x003F);                              // フォント指定色のG要素の算出
       739:                bs          = ((color    >> 11) & 0x001F);                              // フォント指定色のB要素の算出
       740:                alpha       = font_data & 0x1F;                                         // フォントテーブルデータからアルファ量を算出
       741:                rd          = (rd *  alpha       + rs * (0x1F -  alpha      )) / 0x1F;  // R要素のアルファブレンド
       742:                gd          = (gd * (alpha << 1) + gs * (0x3F - (alpha << 1))) / 0x3F;  // G要素のアルファブレンド
       743:                bd          = (bd *  alpha       + bs * (0x1F -  alpha      )) / 0x1F;  // B要素のアルファブレンド
       744:                dst_data    = (rd << 11) | (gd << 5) | bd;  
       745:                if(g_drawbuff_flg)
       746:                {
       747:                    (*(ADATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320))) = dst_data;
       748:                }
       749:                else
       750:                {
       751:                    (*(BDATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320))) = dst_data;
       752:                }
       753:            }
       754:        }
       755:        g_LCD_x = g_LCD_x + 10;
       756:    }
       757:    */
       758:    
       759:    /*
       760:    // --------------------------------------------------------------------
       761:    // TFT LCD 文字単出力（大き目）(ソフトウェア転送版)
       762:    // --------------------------------------------------------------------
       763:    void LCD_CHR_copyBN(unsigned char chr)
       764:    {
       765:        unsigned long i, j, font_addr;
       766:        
       767:        // フォントテーブルデータの座標の参照先を算出
       768:        font_addr = (((((chr - 0x20) & 0x000000F0) >> 4) * 24) * 320) + ((((chr - 0x20) & 0x0000000F) * 16));
       769:        
       770:        for(j = 0; j < 24; j++)
       771:        {
       772:            for(i = 0; i < 16; i++)
       773:            {
       774:                if(g_drawbuff_flg)
       775:                {
       776:                    (*(ADATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320))) = *(FONT + font_addr + i + j * 320);
       777:                }
       778:                else
       779:                {
       780:                    (*(BDATA + ((g_LCD_x + i) + (g_LCD_y + j) * 320))) = *(FONT + font_addr + i + j * 320);
       781:                }
       782:            }
       783:        }
       784:        g_LCD_x = g_LCD_x  + 16;
       785:    }
       786:    */
       787:    
       788:    // --------------------------------------------------------------------
       789:    // TFT LCD 文字単出力（大き目）(ハードウェアDMA0転送版)
       790:    // --------------------------------------------------------------------
       791:    void LCD_CHR_copyBN(unsigned char chr)
  0000094C                    _LCD_CHR_copyBN:                     ; function: LCD_CHR_copyBN
  0000094C 01206DF4               STM.L       (ER4-ER6),@-SP
       792:    {
       793:        unsigned long j, font_addr;
       794:        
       795:        // フォントテーブルデータの座標の参照先を算出
       796:        font_addr = (((((chr - 0x20) & 0x000000F0) >> 4) * 24) * 320) + ((((chr - 0x20) & 0x0000000F) * 16));
       797:        
       798:        for(j = 0; j < 24; j++)
  00000950 1AC4                   SUB.L       ER4,ER4
  00000952 0C89                   MOV.B       R0L,R1L
  00000954 1751                   EXTU.W      R1
  00000956 79310020               SUB.W       #H'0020:16,R1
  0000095A 0D19                   MOV.W       R1,E1
  0000095C 796900F0               AND.W       #H'00F0:16,E1
  00000960 11D9                   SHAR.W      #2,E1
  00000962 11D9                   SHAR.W      #2,E1
  00000964 79001E00               MOV.W       #H'1E00:16,R0
  00000968 01C25009               MULS.W      R0,E1
  0000096C 7961000F               AND.W       #H'000F:16,R1
  00000970 1021                   SHLL.W      #4,R1
  00000972 0919                   ADD.W       R1,E1
  00000974 0D90                   MOV.W       E1,R0
  00000976 17F0                   EXTS.L      ER0
  00000978 1030                   SHLL.L      ER0
  0000097A 7A18F800               ADD.L       #H'F800:16,ER0
  0000097E 0F86                   MOV.L       ER0,ER6
  00000980 7A0500000000           MOV.L       #_g_LCD_x,ER5
  00000986                    L7127:                                
       799:        {
       800:            DMAC0.DTCR = 16 * 2;
  00000986 010D4020FC0C           MOV.L       #H'20:8,@H'00FFFC0C:16
       801:            DMAC0.DSAR = (FONT + font_addr + j * 320);
  0000098C 0FC0                   MOV.L       ER4,ER0
  0000098E 1070                   SHLL.L      #2,ER0
  00000990 0AC0                   ADD.L       ER4,ER0
  00000992 03871030               SHLL.L      #7:5,ER0
  00000996 0AE0                   ADD.L       ER6,ER0
  00000998 01006B80FC00           MOV.L       ER0,@H'00FFFC00:16
       802:            if(g_drawbuff_flg)
  0000099E 6B2000000000           MOV.W       @_g_drawbuff_flg:32,R0
  000009A4 4700                   BEQ         L7129:8
       803:            {
       804:                DMAC0.DDAR = (ADATA + ((g_LCD_x) + (g_LCD_y + j) * 320));
  000009A6 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  000009AC 1770                   EXTU.L      ER0
  000009AE 0AC0                   ADD.L       ER4,ER0
  000009B0 0F81                   MOV.L       ER0,ER1
  000009B2 1070                   SHLL.L      #2,ER0
  000009B4 0A90                   ADD.L       ER1,ER0
  000009B6 03861030               SHLL.L      #6:5,ER0
  000009BA 6951                   MOV.W       @ER5,R1
  000009BC 1771                   EXTU.L      ER1
  000009BE 0A90                   ADD.L       ER1,ER0
  000009C0 1030                   SHLL.L      ER0
  000009C2 7A1000200000           ADD.L       #H'00200000,ER0
  000009C8 4000                   BRA         L7130:8
  000009CA                    L7129:                                
       805:            }
       806:            else
       807:            {
       808:                DMAC0.DDAR = (BDATA + ((g_LCD_x) + (g_LCD_y + j) * 320));
  000009CA 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  000009D0 1770                   EXTU.L      ER0
  000009D2 0AC0                   ADD.L       ER4,ER0
  000009D4 0F81                   MOV.L       ER0,ER1
  000009D6 1070                   SHLL.L      #2,ER0
  000009D8 0A90                   ADD.L       ER1,ER0
  000009DA 03861030               SHLL.L      #6:5,ER0
  000009DE 6951                   MOV.W       @ER5,R1
  000009E0 1771                   EXTU.L      ER1
  000009E2 0A90                   ADD.L       ER1,ER0
  000009E4 1030                   SHLL.L      ER0
  000009E6 7A1000225800           ADD.L       #H'00225800,ER0
  000009EC                    L7130:                                
       809:            }
       810:            DMAC0.DMDR.BIT.DTE  = 1;
  000009EC 01006B80FC04           MOV.L       ER0,@H'00FFFC04:16
  000009F2 6A18FC147070           BSET.B      #7,@H'00FFFC14:16
  000009F8                    L7131:                                
       811:            while(DMAC0.DMDR.BIT.DTIF == 0);
  000009F8 6A08FC15               MOV.B       @H'00FFFC15:16,R0L
  000009FC 7708                   BLD.B       #0,R0L
  000009FE 4400                   BCC         L7131:8
  00000A00 0B74                   INC.L       #1,ER4
  00000A02 7A2C0018               CMP.L       #H'0018:16,ER4
  00000A06 58500000               BLO         L7127:16
       812:        }
       813:        g_LCD_x = g_LCD_x  + 16;
  00000A0A 015E05100010           ADD.W       #H'0010:16,@ER5
  00000A10 5426                   RTS/L       (ER4-ER6)
       814:    }
       815:    
       816:    // --------------------------------------------------------------------
       817:    // TFT LCD 文字単出力（大き目）(ハードウェアDMA0転送版) 展開FONT対象
       818:    // --------------------------------------------------------------------
       819:    void LCD_CHR_copyBNR(unsigned char chr)
  00000A12                    _LCD_CHR_copyBNR:                    ; function: LCD_CHR_copyBNR
  00000A12 01206DF4               STM.L       (ER4-ER6),@-SP
       820:    {
       821:        unsigned long j, font_addr;
       822:        
       823:        // フォントテーブルデータの座標の参照先を算出
       824:        font_addr = (((((chr - 0x20) & 0x000000F0) >> 4) * 24) * 320) + ((((chr - 0x20) & 0x0000000F) * 16));
       825:        
       826:        for(j = 0; j < 24; j++)
  00000A16 1AC4                   SUB.L       ER4,ER4
  00000A18 0C89                   MOV.B       R0L,R1L
  00000A1A 1751                   EXTU.W      R1
  00000A1C 79310020               SUB.W       #H'0020:16,R1
  00000A20 0D19                   MOV.W       R1,E1
  00000A22 796900F0               AND.W       #H'00F0:16,E1
  00000A26 11D9                   SHAR.W      #2,E1
  00000A28 11D9                   SHAR.W      #2,E1
  00000A2A 79001E00               MOV.W       #H'1E00:16,R0
  00000A2E 01C25009               MULS.W      R0,E1
  00000A32 7961000F               AND.W       #H'000F:16,R1
  00000A36 1021                   SHLL.W      #4,R1
  00000A38 0919                   ADD.W       R1,E1
  00000A3A 0D90                   MOV.W       E1,R0
  00000A3C 17F0                   EXTS.L      ER0
  00000A3E 1030                   SHLL.L      ER0
  00000A40 7A100024B000           ADD.L       #H'0024B000,ER0
  00000A46 0F86                   MOV.L       ER0,ER6
  00000A48 7A0500000000           MOV.L       #_g_LCD_x,ER5
  00000A4E                    L7136:                                
       827:        {
       828:            DMAC0.DTCR = 16 * 2;
  00000A4E 010D4020FC0C           MOV.L       #H'20:8,@H'00FFFC0C:16
       829:            DMAC0.DSAR = (FONTR + font_addr + j * 320);
  00000A54 0FC0                   MOV.L       ER4,ER0
  00000A56 1070                   SHLL.L      #2,ER0
  00000A58 0AC0                   ADD.L       ER4,ER0
  00000A5A 03871030               SHLL.L      #7:5,ER0
  00000A5E 0AE0                   ADD.L       ER6,ER0
  00000A60 01006B80FC00           MOV.L       ER0,@H'00FFFC00:16
       830:            if(g_drawbuff_flg)
  00000A66 6B2000000000           MOV.W       @_g_drawbuff_flg:32,R0
  00000A6C 4700                   BEQ         L7138:8
       831:            {
       832:                DMAC0.DDAR = (ADATA + ((g_LCD_x) + (g_LCD_y + j) * 320));
  00000A6E 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000A74 1770                   EXTU.L      ER0
  00000A76 0AC0                   ADD.L       ER4,ER0
  00000A78 0F81                   MOV.L       ER0,ER1
  00000A7A 1070                   SHLL.L      #2,ER0
  00000A7C 0A90                   ADD.L       ER1,ER0
  00000A7E 03861030               SHLL.L      #6:5,ER0
  00000A82 6951                   MOV.W       @ER5,R1
  00000A84 1771                   EXTU.L      ER1
  00000A86 0A90                   ADD.L       ER1,ER0
  00000A88 1030                   SHLL.L      ER0
  00000A8A 7A1000200000           ADD.L       #H'00200000,ER0
  00000A90 4000                   BRA         L7139:8
  00000A92                    L7138:                                
       833:            }
       834:            else
       835:            {
       836:                DMAC0.DDAR = (BDATA + ((g_LCD_x) + (g_LCD_y + j) * 320));
  00000A92 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000A98 1770                   EXTU.L      ER0
  00000A9A 0AC0                   ADD.L       ER4,ER0
  00000A9C 0F81                   MOV.L       ER0,ER1
  00000A9E 1070                   SHLL.L      #2,ER0
  00000AA0 0A90                   ADD.L       ER1,ER0
  00000AA2 03861030               SHLL.L      #6:5,ER0
  00000AA6 6951                   MOV.W       @ER5,R1
  00000AA8 1771                   EXTU.L      ER1
  00000AAA 0A90                   ADD.L       ER1,ER0
  00000AAC 1030                   SHLL.L      ER0
  00000AAE 7A1000225800           ADD.L       #H'00225800,ER0
  00000AB4                    L7139:                                
       837:            }
       838:            DMAC0.DMDR.BIT.DTE  = 1;
  00000AB4 01006B80FC04           MOV.L       ER0,@H'00FFFC04:16
  00000ABA 6A18FC147070           BSET.B      #7,@H'00FFFC14:16
  00000AC0                    L7140:                                
       839:            while(DMAC0.DMDR.BIT.DTIF == 0);
  00000AC0 6A08FC15               MOV.B       @H'00FFFC15:16,R0L
  00000AC4 7708                   BLD.B       #0,R0L
  00000AC6 4400                   BCC         L7140:8
  00000AC8 0B74                   INC.L       #1,ER4
  00000ACA 7A2C0018               CMP.L       #H'0018:16,ER4
  00000ACE 58500000               BLO         L7136:16
       840:        }
       841:        g_LCD_x = g_LCD_x  + 16;
  00000AD2 015E05100010           ADD.W       #H'0010:16,@ER5
  00000AD8 5426                   RTS/L       (ER4-ER6)
       842:    }
       843:    
       844:    // --------------------------------------------------------------------
       845:    // TFT LCD 文字単出力（大き目2倍）(ハードウェアDMA2転送版)
       846:    // --------------------------------------------------------------------
       847:    void LCD_CHR_copyBN2(unsigned char chr)
  00000ADA                    _LCD_CHR_copyBN2:                    ; function: LCD_CHR_copyBN2
  00000ADA 01306DF2               STM.L       (ER2-ER5),@-SP
  00000ADE 01006DF6               PUSH.L      ER6
       848:    {
       849:        unsigned long j, font_addr;
       850:        
       851:        // フォントテーブルデータの座標の参照先を算出
       852:        font_addr = (((((chr - 0x20) & 0x000000F0) >> 4) * 24) * 320) + ((((chr - 0x20) & 0x0000000F) * 16));
       853:        
       854:        for(j = 0; j < 24; j++)
  00000AE2 1AA2                   SUB.L       ER2,ER2
  00000AE4 0C89                   MOV.B       R0L,R1L
  00000AE6 1751                   EXTU.W      R1
  00000AE8 79310020               SUB.W       #H'0020:16,R1
  00000AEC 0D19                   MOV.W       R1,E1
  00000AEE 796900F0               AND.W       #H'00F0:16,E1
  00000AF2 11D9                   SHAR.W      #2,E1
  00000AF4 11D9                   SHAR.W      #2,E1
  00000AF6 79001E00               MOV.W       #H'1E00:16,R0
  00000AFA 01C25009               MULS.W      R0,E1
  00000AFE 7961000F               AND.W       #H'000F:16,R1
  00000B02 1021                   SHLL.W      #4,R1
  00000B04 0919                   ADD.W       R1,E1
  00000B06 0D90                   MOV.W       E1,R0
  00000B08 17F0                   EXTS.L      ER0
  00000B0A 1030                   SHLL.L      ER0
  00000B0C 7A18F800               ADD.L       #H'F800:16,ER0
  00000B10 0F86                   MOV.L       ER0,ER6
  00000B12 FD18                   MOV.B       #H'18:8,R5L
  00000B14                    L7145:                                
       855:        {
       856:            DMAC2.DTCR = 16 * 2;
  00000B14 010D4020FC4C           MOV.L       #H'20:8,@H'00FFFC4C:16
       857:            DMAC2.DSAR = (FONT + font_addr + j * 320);
  00000B1A 0FA0                   MOV.L       ER2,ER0
  00000B1C 1070                   SHLL.L      #2,ER0
  00000B1E 0AA0                   ADD.L       ER2,ER0
  00000B20 03871030               SHLL.L      #7:5,ER0
  00000B24 0AE0                   ADD.L       ER6,ER0
  00000B26 0F84                   MOV.L       ER0,ER4
  00000B28 01006B80FC40           MOV.L       ER0,@H'00FFFC40:16
       858:            if(g_drawbuff_flg)
  00000B2E 0FA9                   MOV.L       #2:3,ER1
  00000B30 0FA0                   MOV.L       ER2,ER0
  00000B32 01CA5210               MULU.L      ER1,ER0
  00000B36 0F83                   MOV.L       ER0,ER3
  00000B38 6B2000000000           MOV.W       @_g_drawbuff_flg:32,R0
  00000B3E 4700                   BEQ         L7147:8
       859:            {
       860:                DMAC2.DDAR = (ADATA + ((g_LCD_x    ) + (g_LCD_y + j * 2    ) * 320));
  00000B40 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000B46 1770                   EXTU.L      ER0
  00000B48 0AB0                   ADD.L       ER3,ER0
  00000B4A 0F81                   MOV.L       ER0,ER1
  00000B4C 1070                   SHLL.L      #2,ER0
  00000B4E 0A90                   ADD.L       ER1,ER0
  00000B50 03861030               SHLL.L      #6:5,ER0
  00000B54 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  00000B5A 1771                   EXTU.L      ER1
  00000B5C 0A90                   ADD.L       ER1,ER0
  00000B5E 1030                   SHLL.L      ER0
  00000B60 7A1000200000           ADD.L       #H'00200000,ER0
  00000B66 4000                   BRA         L7148:8
  00000B68                    L7147:                                
       861:            }
       862:            else
       863:            {
       864:                DMAC2.DDAR = (BDATA + ((g_LCD_x    ) + (g_LCD_y + j * 2    ) * 320));
  00000B68 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000B6E 1770                   EXTU.L      ER0
  00000B70 0AB0                   ADD.L       ER3,ER0
  00000B72 0F81                   MOV.L       ER0,ER1
  00000B74 1070                   SHLL.L      #2,ER0
  00000B76 0A90                   ADD.L       ER1,ER0
  00000B78 03861030               SHLL.L      #6:5,ER0
  00000B7C 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  00000B82 1771                   EXTU.L      ER1
  00000B84 0A90                   ADD.L       ER1,ER0
  00000B86 1030                   SHLL.L      ER0
  00000B88 7A1000225800           ADD.L       #H'00225800,ER0
  00000B8E                    L7148:                                
       865:            }
       866:            DMAC2.DMDR.BIT.DTE  = 1;
  00000B8E 01006B80FC44           MOV.L       ER0,@H'00FFFC44:16
  00000B94 6A18FC547070           BSET.B      #7,@H'00FFFC54:16
  00000B9A                    L7149:                                
       867:            while(DMAC2.DMDR.BIT.DTIF == 0);
  00000B9A 6A08FC55               MOV.B       @H'00FFFC55:16,R0L
  00000B9E 7708                   BLD.B       #0,R0L
  00000BA0 4400                   BCC         L7149:8
       868:            
       869:            
       870:            DMAC2.DTCR = 16 * 2;
  00000BA2 010D4020FC4C           MOV.L       #H'20:8,@H'00FFFC4C:16
       871:            DMAC2.DSAR = (FONT + font_addr + j * 320);
  00000BA8 01006B84FC40           MOV.L       ER4,@H'00FFFC40:16
       872:            if(g_drawbuff_flg)
  00000BAE 6B2000000000           MOV.W       @_g_drawbuff_flg:32,R0
  00000BB4 4700                   BEQ         L7152:8
       873:            {
       874:                DMAC2.DDAR = (ADATA + ((g_LCD_x + 1) + (g_LCD_y + j * 2    ) * 320));
  00000BB6 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000BBC 1770                   EXTU.L      ER0
  00000BBE 0AB0                   ADD.L       ER3,ER0
  00000BC0 0F81                   MOV.L       ER0,ER1
  00000BC2 1070                   SHLL.L      #2,ER0
  00000BC4 0A90                   ADD.L       ER1,ER0
  00000BC6 03861030               SHLL.L      #6:5,ER0
  00000BCA 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  00000BD0 0B51                   INC.W       #1,R1
  00000BD2 1771                   EXTU.L      ER1
  00000BD4 0A90                   ADD.L       ER1,ER0
  00000BD6 1030                   SHLL.L      ER0
  00000BD8 7A1000200000           ADD.L       #H'00200000,ER0
  00000BDE 4000                   BRA         L7153:8
  00000BE0                    L7152:                                
       875:            }
       876:            else
       877:            {
       878:                DMAC2.DDAR = (BDATA + ((g_LCD_x + 1) + (g_LCD_y + j * 2    ) * 320));
  00000BE0 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000BE6 1770                   EXTU.L      ER0
  00000BE8 0AB0                   ADD.L       ER3,ER0
  00000BEA 0F81                   MOV.L       ER0,ER1
  00000BEC 1070                   SHLL.L      #2,ER0
  00000BEE 0A90                   ADD.L       ER1,ER0
  00000BF0 03861030               SHLL.L      #6:5,ER0
  00000BF4 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  00000BFA 0B51                   INC.W       #1,R1
  00000BFC 1771                   EXTU.L      ER1
  00000BFE 0A90                   ADD.L       ER1,ER0
  00000C00 1030                   SHLL.L      ER0
  00000C02 7A1000225800           ADD.L       #H'00225800,ER0
  00000C08                    L7153:                                
       879:            }
       880:            DMAC2.DMDR.BIT.DTE  = 1;
  00000C08 01006B80FC44           MOV.L       ER0,@H'00FFFC44:16
  00000C0E 6A18FC547070           BSET.B      #7,@H'00FFFC54:16
  00000C14                    L7154:                                
       881:            while(DMAC2.DMDR.BIT.DTIF == 0);
  00000C14 6A08FC55               MOV.B       @H'00FFFC55:16,R0L
  00000C18 7708                   BLD.B       #0,R0L
  00000C1A 4400                   BCC         L7154:8
       882:            DMAC2.DTCR = 16 * 2;
  00000C1C 010D4020FC4C           MOV.L       #H'20:8,@H'00FFFC4C:16
       883:            DMAC2.DSAR = (FONT + font_addr + j * 320);
  00000C22 01006B84FC40           MOV.L       ER4,@H'00FFFC40:16
       884:            if(g_drawbuff_flg)
  00000C28 6B2000000000           MOV.W       @_g_drawbuff_flg:32,R0
  00000C2E 4700                   BEQ         L7157:8
       885:            {
       886:                DMAC2.DDAR = (ADATA + ((g_LCD_x    ) + (g_LCD_y + j * 2 + 1) * 320));
  00000C30 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000C36 1770                   EXTU.L      ER0
  00000C38 0AB0                   ADD.L       ER3,ER0
  00000C3A 0F81                   MOV.L       ER0,ER1
  00000C3C 1070                   SHLL.L      #2,ER0
  00000C3E 0A90                   ADD.L       ER1,ER0
  00000C40 03861030               SHLL.L      #6:5,ER0
  00000C44 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  00000C4A 1771                   EXTU.L      ER1
  00000C4C 0A90                   ADD.L       ER1,ER0
  00000C4E 1030                   SHLL.L      ER0
  00000C50 7A1000200280           ADD.L       #H'00200280,ER0
  00000C56 4000                   BRA         L7158:8
  00000C58                    L7157:                                
       887:            }
       888:            else
       889:            {
       890:                DMAC2.DDAR = (BDATA + ((g_LCD_x    ) + (g_LCD_y + j * 2 + 1) * 320));
  00000C58 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000C5E 1770                   EXTU.L      ER0
  00000C60 0AB0                   ADD.L       ER3,ER0
  00000C62 0F81                   MOV.L       ER0,ER1
  00000C64 1070                   SHLL.L      #2,ER0
  00000C66 0A90                   ADD.L       ER1,ER0
  00000C68 03861030               SHLL.L      #6:5,ER0
  00000C6C 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  00000C72 1771                   EXTU.L      ER1
  00000C74 0A90                   ADD.L       ER1,ER0
  00000C76 1030                   SHLL.L      ER0
  00000C78 7A1000225A80           ADD.L       #H'00225A80,ER0
  00000C7E                    L7158:                                
       891:            }
       892:            DMAC2.DMDR.BIT.DTE  = 1;
  00000C7E 01006B80FC44           MOV.L       ER0,@H'00FFFC44:16
  00000C84 6A18FC547070           BSET.B      #7,@H'00FFFC54:16
  00000C8A                    L7159:                                
       893:            while(DMAC2.DMDR.BIT.DTIF == 0);
  00000C8A 6A08FC55               MOV.B       @H'00FFFC55:16,R0L
  00000C8E 7708                   BLD.B       #0,R0L
  00000C90 4400                   BCC         L7159:8
       894:            
       895:            
       896:            DMAC2.DTCR = 16 * 2;
  00000C92 010D4020FC4C           MOV.L       #H'20:8,@H'00FFFC4C:16
       897:            DMAC2.DSAR = (FONT + font_addr + j * 320);
  00000C98 01006B84FC40           MOV.L       ER4,@H'00FFFC40:16
       898:            if(g_drawbuff_flg)
  00000C9E 6B2000000000           MOV.W       @_g_drawbuff_flg:32,R0
  00000CA4 4700                   BEQ         L7162:8
       899:            {
       900:                DMAC2.DDAR = (ADATA + ((g_LCD_x + 1) + (g_LCD_y + j * 2 + 1) * 320));
  00000CA6 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000CAC 1770                   EXTU.L      ER0
  00000CAE 0AB0                   ADD.L       ER3,ER0
  00000CB0 0F81                   MOV.L       ER0,ER1
  00000CB2 1070                   SHLL.L      #2,ER0
  00000CB4 0A90                   ADD.L       ER1,ER0
  00000CB6 03861030               SHLL.L      #6:5,ER0
  00000CBA 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  00000CC0 0B51                   INC.W       #1,R1
  00000CC2 1771                   EXTU.L      ER1
  00000CC4 0A90                   ADD.L       ER1,ER0
  00000CC6 1030                   SHLL.L      ER0
  00000CC8 7A1000200280           ADD.L       #H'00200280,ER0
  00000CCE 4000                   BRA         L7163:8
  00000CD0                    L7162:                                
       901:            }
       902:            else
       903:            {
       904:                DMAC2.DDAR = (BDATA + ((g_LCD_x + 1) + (g_LCD_y + j * 2 + 1) * 320));
  00000CD0 6B2000000000           MOV.W       @_g_LCD_y:32,R0
  00000CD6 1770                   EXTU.L      ER0
  00000CD8 0AB0                   ADD.L       ER3,ER0
  00000CDA 0F81                   MOV.L       ER0,ER1
  00000CDC 1070                   SHLL.L      #2,ER0
  00000CDE 0A90                   ADD.L       ER1,ER0
  00000CE0 03861030               SHLL.L      #6:5,ER0
  00000CE4 6B2100000000           MOV.W       @_g_LCD_x:32,R1
  00000CEA 0B51                   INC.W       #1,R1
  00000CEC 1771                   EXTU.L      ER1
  00000CEE 0A90                   ADD.L       ER1,ER0
  00000CF0 1030                   SHLL.L      ER0
  00000CF2 7A1000225A80           ADD.L       #H'00225A80,ER0
  00000CF8                    L7163:                                
       905:            }
       906:            DMAC2.DMDR.BIT.DTE  = 1;
  00000CF8 01006B80FC44           MOV.L       ER0,@H'00FFFC44:16
  00000CFE 6A18FC547070           BSET.B      #7,@H'00FFFC54:16
  00000D04                    L7164:                                
       907:            while(DMAC2.DMDR.BIT.DTIF == 0);
  00000D04 6A08FC55               MOV.B       @H'00FFFC55:16,R0L
  00000D08 7708                   BLD.B       #0,R0L
  00000D0A 4400                   BCC         L7164:8
  00000D0C 0B72                   INC.L       #1,ER2
  00000D0E 1A0D                   DEC.B       R5L
  00000D10 58600000               BNE         L7145:16
       908:    
       909:        }
       910:        g_LCD_x = g_LCD_x  + 32;
  00000D14 015E481000000000       ADD.W       #H'0020:16,@_g_LCD_x:32
           0020               
  00000D1E 01006D76               POP.L       ER6
  00000D22 5435                   RTS/L       (ER2-ER5)
       911:    }
       912:    
       913:    /*
       914:    // --------------------------------------------------------------------
       915:    // TFT LCD 文字列出力（大き目）
       916:    // --------------------------------------------------------------------
       917:    void LCD_CHR_drawBN(unsigned char chr[])
       918:    {
       919:        unsigned int i;
       920:        
       921:        for(i = 0; i <= 19; i++)
       922:        {
       923:            if(chr[i] == '\0') return;
       924:            LCD_CHR_copyBN(chr[i]);
       925:        }
       926:    }
       927:    */
       928:    
       929:    // --------------------------------------------------------------------
       930:    // TFT LCD 整数値出力（小さ目）
       931:    // --------------------------------------------------------------------
       932:    void LCD_INT_draw(int num, unsigned int figure, unsigned int dp)
  00000D24                    _LCD_INT_draw:                       ; function: LCD_INT_draw
  00000D24 01306DF2               STM.L       (ER2-ER5),@-SP
  00000D28 6DF6                   PUSH.W      R6
  00000D2A 1A67                   SUB.W       #6:3,R7
       933:    {
       934:        int i, j, k, l, numw;
       935:        unsigned char chr[6], temp, sign;
       936:        
       937:        if( figure > 8 ) return;
  00000D2C 0D14                   MOV.W       R1,R4
  00000D2E 0D8D                   MOV.W       E0,E5
  00000D30 0D02                   MOV.W       R0,R2
  00000D32 79280008               CMP.W       #8:16,E0
  00000D36 58200000               BHI         L7170:16
       938:        
       939:        if( num < 0)
  00000D3A 0D22                   MOV.W       R2,R2
  00000D3C 4C00                   BGE         L7172:8
       940:        {
       941:            num = (~num) + 1;
  00000D3E 1792                   NEG.W       R2
       942:            sign = 1;
  00000D40 4001                   BRA/S       L7173:8
  00000D42 FE01                   MOV.B       #1:8,R6L
  00000D44                    L7172:                                
       943:        }
       944:        else
       945:        {
       946:            sign = 0;
  00000D44 18EE                   SUB.B       R6L,R6L
  00000D46                    L7173:                                
       947:        }
       948:        
       949:        numw = num;
  00000D46 0D29                   MOV.W       R2,E1
       950:        if(dp > 0)
  00000D48 0D44                   MOV.W       R4,R4
  00000D4A 4700                   BEQ         L7175:8
       951:        {
       952:            for(i = 1; i <= dp; i ++ )
  00000D4C 4001                   BRA/S       L7176:8
  00000D4E 0F10                   MOV.W       #1:3,R0
  00000D50                    L7177:                                
       953:            {
       954:                numw = numw / 10;
  00000D50 01D651A9               DIVS.W      #H'A:4,E1
  00000D54 0B50                   INC.W       #1,R0
  00000D56                    L7176:                                
  00000D56 1D40                   CMP.W       R4,R0
  00000D58 4300                   BLS         L7177:8
  00000D5A                    L7175:                                
       955:            }
       956:        }
       957:        
       958:        i = 0;
  00000D5A 19AA                   SUB.W       E2,E2
       959:        l = 0;
       960:        if(numw >= 10)
  00000D5C 7929000A               CMP.W       #H'000A:16,E1
  00000D60 4C00                   BGE         L7179:8
  00000D62 0D45                   MOV.W       R4,R5
  00000D64 0B55                   INC.W       #1,R5
  00000D66 19CC                   SUB.W       E4,E4
  00000D68                    L7180:                                
       961:        {
       962:            do                              // 各桁数値の抽出ループ
       963:            {
       964:                temp = num % 10;            // 下位の桁から数字を抽出
       965:                chr[i ++ ] = temp + '0';    // 数字を文字コードに変換
       966:                if(i == dp)                 // 小数点位置の場合
       967:                chr[i ++ ] = '.';           // 小数点を格納
       968:            } while (( num /= 10 ) != 0);   // 数値の桁数までループ
       969:        }
       970:        else
       971:        {
       972:            do                              // 各桁数値の抽出ループ
       973:            {
       974:                temp = num % 10;            // 下位の桁から数字を抽出
       975:                chr[i ++ ] = temp + '0';    // 数字を文字コードに変換
  00000D68 0D20                   MOV.W       R2,R0
  00000D6A 17F0                   EXTS.L      ER0
  00000D6C 01D453A0               DIVXS.W     #H'A:4,ER0
  00000D70 0D80                   MOV.W       E0,R0
  00000D72 0C81                   MOV.B       R0L,R1H
  00000D74 8130                   ADD.B       #H'30:8,R1H
  00000D76 0DA0                   MOV.W       E2,R0
  00000D78 17F0                   EXTS.L      ER0
  00000D7A 0AF0                   ADD.L       SP,ER0
  00000D7C 6881                   MOV.B       R1H,@ER0
  00000D7E 0B5A                   INC.W       #1,E2
       976:                if(i == dp)                 // 小数点位置の場合
  00000D80 1D4A                   CMP.W       R4,E2
  00000D82 4600                   BNE         L7182:8
       977:                {
       978:                chr[i ++ ] = '.';           // 小数点を格納
  00000D84 0DA0                   MOV.W       E2,R0
  00000D86 17F0                   EXTS.L      ER0
  00000D88 0AF0                   ADD.L       SP,ER0
  00000D8A 017D002E               MOV.B       #H'2E:8,@ER0
  00000D8E 0B5A                   INC.W       #1,E2
       979:                l = 1;
  00000D90 0F1C                   MOV.W       #1:3,E4
  00000D92                    L7182:                                
       980:                }
       981:                num /= 10;
  00000D92 01D651A2               DIVS.W      #H'A:4,R2
  00000D96 0DC9                   MOV.W       E4,E1
  00000D98 0959                   ADD.W       R5,E1
  00000D9A 1D9A                   CMP.W       E1,E2
  00000D9C 4700                   BEQ         L7183:8
  00000D9E 4000                   BRA         L7180:8
  00000DA0                    L7179:                                
  00000DA0 0D20                   MOV.W       R2,R0
  00000DA2 17F0                   EXTS.L      ER0
  00000DA4 01D453A0               DIVXS.W     #H'A:4,ER0
  00000DA8 0D80                   MOV.W       E0,R0
  00000DAA 0C81                   MOV.B       R0L,R1H
  00000DAC 8130                   ADD.B       #H'30:8,R1H
  00000DAE 0DA0                   MOV.W       E2,R0
  00000DB0 17F0                   EXTS.L      ER0
  00000DB2 0AF0                   ADD.L       SP,ER0
  00000DB4 6881                   MOV.B       R1H,@ER0
  00000DB6 0B5A                   INC.W       #1,E2
  00000DB8 1D4A                   CMP.W       R4,E2
  00000DBA 4600                   BNE         L7185:8
  00000DBC 0DA1                   MOV.W       E2,R1
  00000DBE 17F1                   EXTS.L      ER1
  00000DC0 0FF0                   MOV.L       SP,ER0
  00000DC2 0AF1                   ADD.L       SP,ER1
  00000DC4 017D012E               MOV.B       #H'2E:8,@ER1
  00000DC8 0B5A                   INC.W       #1,E2
  00000DCA                    L7185:                                
  00000DCA 01D651A2               DIVS.W      #H'A:4,R2
  00000DCE 0D22                   MOV.W       R2,R2
  00000DD0 4600                   BNE         L7179:8
  00000DD2                    L7183:                                
       982:            } while (i != (dp + 1 + l));        // 数値の桁数までループ
       983:        }
       984:        
       985:        i --;
  00000DD2 1B5A                   DEC.W       #1,E2
       986:        
       987:        if((figure - 1) < i)                //表示桁数チェック
  00000DD4 0DD8                   MOV.W       E5,E0
  00000DD6 1B5D                   DEC.W       #1,E5
  00000DD8 0DD0                   MOV.W       E5,R0
  00000DDA 1DAD                   CMP.W       E2,E5
  00000DDC 4500                   BLO         L7170:8
       988:        {
       989:            return;
       990:        }
       991:        
       992:        if(i == (figure - 1))               //MAX桁の場合
  00000DDE 1D0A                   CMP.W       R0,E2
  00000DE0 4600                   BNE         L7188:8
       993:        {
       994:            i += 1;                         //頭の桁を１つ増やす
  00000DE2 0B5A                   INC.W       #1,E2
       995:            if(sign == 1)
  00000DE4 0DA0                   MOV.W       E2,R0
  00000DE6 17F0                   EXTS.L      ER0
  00000DE8 0AF0                   ADD.L       SP,ER0
  00000DEA AE01                   CMP.B       #1:8,R6L
  00000DEC 4600                   BNE         L7190:8
       996:            {
       997:                chr[i] = '-';               //頭桁に-記号付加
  00000DEE 017D002D               MOV.B       #H'2D:8,@ER0
  00000DF2 4000                   BRA         L7191:8
  00000DF4                    L7190:                                
       998:            }
       999:            else
      1000:            {
      1001:                chr[i] = ' ';               //頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
  00000DF4 017D0020               MOV.B       #H'20:8,@ER0
  00000DF8 4000                   BRA         L7191:8
  00000DFA                    L7188:                                
      1002:            }
      1003:        }
      1004:        else
      1005:        {                                   //MAX桁以下の場合
      1006:            for( j = 0; j < ((figure) -i ); j++ )       //最初に頭から不足桁数分のｽﾍﾟｰｽ付加
  00000DFA 1922                   SUB.W       R2,R2
  00000DFC 0D84                   MOV.W       E0,R4
  00000DFE 19A4                   SUB.W       E2,R4
  00000E00 0D0C                   MOV.W       R0,E4
  00000E02 4001                   BRA/S       L7192:8
  00000E04 19AC                   SUB.W       E2,E4
  00000E06                    L7193:                                
      1007:            {
      1008:                if(j == ((figure - 1) - i ))//数値頭の±符号処理
  00000E06 1DC2                   CMP.W       E4,R2
  00000E08 4600                   BNE         L7195:8
      1009:                {
      1010:                    if(sign == 1)
  00000E0A AE01                   CMP.B       #1:8,R6L
  00000E0C 4600                   BNE         L7195:8
      1011:                    {
      1012:                        LCD_CHR_Copy_Smallfont('-');    //頭桁に-記号付加
  00000E0E 4001                   BRA/S       L7197:8
  00000E10 F82D                   MOV.B       #H'2D:8,R0L
  00000E12                    L7195:                                
  00000E12 F820                   MOV.B       #H'20:8,R0L
  00000E14                    L7197:                                
  00000E14 5E000000               JSR         @_LCD_CHR_Copy_Smallfont:24
  00000E18 0B52                   INC.W       #1,R2
  00000E1A                    L7192:                                
  00000E1A 1D42                   CMP.W       R4,R2
  00000E1C 4500                   BLO         L7193:8
  00000E1E                    L7191:                                
      1013:                    }
      1014:                    else
      1015:                    {
      1016:                        LCD_CHR_Copy_Smallfont(' ');    //頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
      1017:                    }
      1018:                }
      1019:                else
      1020:                {
      1021:                    LCD_CHR_Copy_Smallfont(' ');    //不足桁数だけスペース表示
      1022:                }            
      1023:            }
      1024:        }
      1025:        // 数字コード表示ルーチン
      1026:        for(k = i; k >= 0; k --)            // 上位の桁から順次
  00000E1E 4001                   BRA/S       L7198:8
  00000E20 0DA2                   MOV.W       E2,R2
  00000E22                    L7199:                                
      1027:        {
      1028:            LCD_CHR_Copy_Smallfont(chr[k]);
  00000E22 0D20                   MOV.W       R2,R0
  00000E24 17F0                   EXTS.L      ER0
  00000E26 0AF0                   ADD.L       SP,ER0
  00000E28 6808                   MOV.B       @ER0,R0L
  00000E2A 5E000000               JSR         @_LCD_CHR_Copy_Smallfont:24
  00000E2E 1A12                   SUB.W       #1:3,R2
  00000E30                    L7198:                                
  00000E30 0D22                   MOV.W       R2,R2
  00000E32 4C00                   BGE         L7199:8
  00000E34                    L7170:                                
  00000E34 0A67                   ADD.W       #6:3,R7
  00000E36 6D76                   POP.W       R6
  00000E38 5435                   RTS/L       (ER2-ER5)
      1029:        }
      1030:    }
      1031:    
      1032:    // --------------------------------------------------------------------
      1033:    // TFT LCD 整数値出力（大き目）
      1034:    // --------------------------------------------------------------------
      1035:    void LCD_INT_drawBN(int num, unsigned int figure, unsigned int dp)
  00000E3A                    _LCD_INT_drawBN:                     ; function: LCD_INT_drawBN
  00000E3A 01306DF2               STM.L       (ER2-ER5),@-SP
  00000E3E 6DF6                   PUSH.W      R6
  00000E40 1A67                   SUB.W       #6:3,R7
      1036:    {
      1037:        int i, j, k, l, numw;
      1038:        unsigned char chr[6], temp, sign;
      1039:        
      1040:        if( figure > 8 ) return;
  00000E42 0D14                   MOV.W       R1,R4
  00000E44 0D8D                   MOV.W       E0,E5
  00000E46 0D02                   MOV.W       R0,R2
  00000E48 79280008               CMP.W       #8:16,E0
  00000E4C 58200000               BHI         L7202:16
      1041:        
      1042:        if( num < 0)
  00000E50 0D22                   MOV.W       R2,R2
  00000E52 4C00                   BGE         L7204:8
      1043:        {
      1044:            num = (~num) + 1;
  00000E54 1792                   NEG.W       R2
      1045:            sign = 1;
  00000E56 4001                   BRA/S       L7205:8
  00000E58 FE01                   MOV.B       #1:8,R6L
  00000E5A                    L7204:                                
      1046:        }
      1047:        else
      1048:        {
      1049:            sign = 0;
  00000E5A 18EE                   SUB.B       R6L,R6L
  00000E5C                    L7205:                                
      1050:        }
      1051:        
      1052:        numw = num;
  00000E5C 0D29                   MOV.W       R2,E1
      1053:        if(dp > 0)
  00000E5E 0D44                   MOV.W       R4,R4
  00000E60 4700                   BEQ         L7207:8
      1054:        {
      1055:            for(i = 1; i <= dp; i ++ )
  00000E62 4001                   BRA/S       L7208:8
  00000E64 0F10                   MOV.W       #1:3,R0
  00000E66                    L7209:                                
      1056:            {
      1057:                numw = numw / 10;
  00000E66 01D651A9               DIVS.W      #H'A:4,E1
  00000E6A 0B50                   INC.W       #1,R0
  00000E6C                    L7208:                                
  00000E6C 1D40                   CMP.W       R4,R0
  00000E6E 4300                   BLS         L7209:8
  00000E70                    L7207:                                
      1058:            }
      1059:        }
      1060:        
      1061:        i = 0;
  00000E70 19AA                   SUB.W       E2,E2
      1062:        l = 0;
      1063:        if(numw >= 10)
  00000E72 7929000A               CMP.W       #H'000A:16,E1
  00000E76 4C00                   BGE         L7211:8
  00000E78 0D45                   MOV.W       R4,R5
  00000E7A 0B55                   INC.W       #1,R5
  00000E7C 19CC                   SUB.W       E4,E4
  00000E7E                    L7212:                                
      1064:        {
      1065:            do                              // 各桁数値の抽出ループ
      1066:            {
      1067:                temp = num % 10;            // 下位の桁から数字を抽出
      1068:                chr[i ++ ] = temp + '0';    // 数字を文字コードに変換
      1069:                if(i == dp)                 // 小数点位置の場合
      1070:                chr[i ++ ] = '.';           // 小数点を格納
      1071:            } while (( num /= 10 ) != 0);   // 数値の桁数までループ
      1072:        }
      1073:        else
      1074:        {
      1075:            do                              // 各桁数値の抽出ループ
      1076:            {
      1077:                temp = num % 10;            // 下位の桁から数字を抽出
      1078:                chr[i ++ ] = temp + '0';    // 数字を文字コードに変換
  00000E7E 0D20                   MOV.W       R2,R0
  00000E80 17F0                   EXTS.L      ER0
  00000E82 01D453A0               DIVXS.W     #H'A:4,ER0
  00000E86 0D80                   MOV.W       E0,R0
  00000E88 0C81                   MOV.B       R0L,R1H
  00000E8A 8130                   ADD.B       #H'30:8,R1H
  00000E8C 0DA0                   MOV.W       E2,R0
  00000E8E 17F0                   EXTS.L      ER0
  00000E90 0AF0                   ADD.L       SP,ER0
  00000E92 6881                   MOV.B       R1H,@ER0
  00000E94 0B5A                   INC.W       #1,E2
      1079:                if(i == dp)                 // 小数点位置の場合
  00000E96 1D4A                   CMP.W       R4,E2
  00000E98 4600                   BNE         L7214:8
      1080:                {
      1081:                chr[i ++ ] = '.';           // 小数点を格納
  00000E9A 0DA0                   MOV.W       E2,R0
  00000E9C 17F0                   EXTS.L      ER0
  00000E9E 0AF0                   ADD.L       SP,ER0
  00000EA0 017D002E               MOV.B       #H'2E:8,@ER0
  00000EA4 0B5A                   INC.W       #1,E2
      1082:                l = 1;
  00000EA6 0F1C                   MOV.W       #1:3,E4
  00000EA8                    L7214:                                
      1083:                }
      1084:                num /= 10;
  00000EA8 01D651A2               DIVS.W      #H'A:4,R2
  00000EAC 0DC9                   MOV.W       E4,E1
  00000EAE 0959                   ADD.W       R5,E1
  00000EB0 1D9A                   CMP.W       E1,E2
  00000EB2 4700                   BEQ         L7215:8
  00000EB4 4000                   BRA         L7212:8
  00000EB6                    L7211:                                
  00000EB6 0D20                   MOV.W       R2,R0
  00000EB8 17F0                   EXTS.L      ER0
  00000EBA 01D453A0               DIVXS.W     #H'A:4,ER0
  00000EBE 0D80                   MOV.W       E0,R0
  00000EC0 0C81                   MOV.B       R0L,R1H
  00000EC2 8130                   ADD.B       #H'30:8,R1H
  00000EC4 0DA0                   MOV.W       E2,R0
  00000EC6 17F0                   EXTS.L      ER0
  00000EC8 0AF0                   ADD.L       SP,ER0
  00000ECA 6881                   MOV.B       R1H,@ER0
  00000ECC 0B5A                   INC.W       #1,E2
  00000ECE 1D4A                   CMP.W       R4,E2
  00000ED0 4600                   BNE         L7217:8
  00000ED2 0DA1                   MOV.W       E2,R1
  00000ED4 17F1                   EXTS.L      ER1
  00000ED6 0FF0                   MOV.L       SP,ER0
  00000ED8 0AF1                   ADD.L       SP,ER1
  00000EDA 017D012E               MOV.B       #H'2E:8,@ER1
  00000EDE 0B5A                   INC.W       #1,E2
  00000EE0                    L7217:                                
  00000EE0 01D651A2               DIVS.W      #H'A:4,R2
  00000EE4 0D22                   MOV.W       R2,R2
  00000EE6 4600                   BNE         L7211:8
  00000EE8                    L7215:                                
      1085:            } while (i != (dp + 1 + l));        // 数値の桁数までループ
      1086:        }
      1087:        
      1088:        i --;
  00000EE8 1B5A                   DEC.W       #1,E2
      1089:        
      1090:        if((figure - 1) < i)                //表示桁数チェック
  00000EEA 0DD8                   MOV.W       E5,E0
  00000EEC 1B5D                   DEC.W       #1,E5
  00000EEE 0DD0                   MOV.W       E5,R0
  00000EF0 1DAD                   CMP.W       E2,E5
  00000EF2 4500                   BLO         L7202:8
      1091:        {
      1092:            return;
      1093:        }
      1094:        
      1095:        if(i == (figure - 1))               //MAX桁の場合
  00000EF4 1D0A                   CMP.W       R0,E2
  00000EF6 4600                   BNE         L7220:8
      1096:        {
      1097:            i += 1;                         //頭の桁を１つ増やす
  00000EF8 0B5A                   INC.W       #1,E2
      1098:            if(sign == 1)
  00000EFA 0DA0                   MOV.W       E2,R0
  00000EFC 17F0                   EXTS.L      ER0
  00000EFE 0AF0                   ADD.L       SP,ER0
  00000F00 AE01                   CMP.B       #1:8,R6L
  00000F02 4600                   BNE         L7222:8
      1099:            {
      1100:                chr[i] = '-';               //頭桁に-記号付加
  00000F04 017D002D               MOV.B       #H'2D:8,@ER0
  00000F08 4000                   BRA         L7223:8
  00000F0A                    L7222:                                
      1101:            }
      1102:            else
      1103:            {
      1104:                chr[i] = ' ';               //頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
  00000F0A 017D0020               MOV.B       #H'20:8,@ER0
  00000F0E 4000                   BRA         L7223:8
  00000F10                    L7220:                                
      1105:            }
      1106:        }
      1107:        else
      1108:        {                                   //MAX桁以下の場合
      1109:            for( j = 0; j < ((figure) -i ); j++ )       //最初に頭から不足桁数分のｽﾍﾟｰｽ付加
  00000F10 1922                   SUB.W       R2,R2
  00000F12 0D84                   MOV.W       E0,R4
  00000F14 19A4                   SUB.W       E2,R4
  00000F16 0D0C                   MOV.W       R0,E4
  00000F18 4001                   BRA/S       L7224:8
  00000F1A 19AC                   SUB.W       E2,E4
  00000F1C                    L7225:                                
      1110:            {
      1111:                if(j == ((figure - 1) - i ))//数値頭の±符号処理
  00000F1C 1DC2                   CMP.W       E4,R2
  00000F1E 4600                   BNE         L7227:8
      1112:                {
      1113:                    if(sign == 1)
  00000F20 AE01                   CMP.B       #1:8,R6L
  00000F22 4600                   BNE         L7227:8
      1114:                    {
      1115:                        LCD_CHR_copyBN('-');    //頭桁に-記号付加
  00000F24 4001                   BRA/S       L7229:8
  00000F26 F82D                   MOV.B       #H'2D:8,R0L
  00000F28                    L7227:                                
  00000F28 F820                   MOV.B       #H'20:8,R0L
  00000F2A                    L7229:                                
  00000F2A 5E000000               JSR         @_LCD_CHR_copyBN:24
  00000F2E 0B52                   INC.W       #1,R2
  00000F30                    L7224:                                
  00000F30 1D42                   CMP.W       R4,R2
  00000F32 4500                   BLO         L7225:8
  00000F34                    L7223:                                
      1116:                    }
      1117:                    else
      1118:                    {
      1119:                        LCD_CHR_copyBN(' ');    //頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
      1120:                    }
      1121:                }
      1122:                else
      1123:                {
      1124:                    LCD_CHR_copyBN(' ');    //不足桁数だけスペース表示
      1125:                }            
      1126:            }
      1127:        }
      1128:        // 数字コード表示ルーチン
      1129:        for(k = i; k >= 0; k --)            // 上位の桁から順次
  00000F34 4001                   BRA/S       L7230:8
  00000F36 0DA2                   MOV.W       E2,R2
  00000F38                    L7231:                                
      1130:        {
      1131:            LCD_CHR_copyBN(chr[k]);
  00000F38 0D20                   MOV.W       R2,R0
  00000F3A 17F0                   EXTS.L      ER0
  00000F3C 0AF0                   ADD.L       SP,ER0
  00000F3E 6808                   MOV.B       @ER0,R0L
  00000F40 5E000000               JSR         @_LCD_CHR_copyBN:24
  00000F44 1A12                   SUB.W       #1:3,R2
  00000F46                    L7230:                                
  00000F46 0D22                   MOV.W       R2,R2
  00000F48 4C00                   BGE         L7231:8
  00000F4A                    L7202:                                
  00000F4A 0A67                   ADD.W       #6:3,R7
  00000F4C 6D76                   POP.W       R6
  00000F4E 5435                   RTS/L       (ER2-ER5)
      1132:        }
      1133:    }
      1134:    
      1135:    // --------------------------------------------------------------------
      1136:    // TFT LCD 整数値出力（大き目）展開FONT対象
      1137:    // --------------------------------------------------------------------
      1138:    void LCD_INT_drawBNR(int num, unsigned int figure, unsigned int dp)
  00000F50                    _LCD_INT_drawBNR:                    ; function: LCD_INT_drawBNR
  00000F50 01306DF2               STM.L       (ER2-ER5),@-SP
  00000F54 6DF6                   PUSH.W      R6
  00000F56 1A67                   SUB.W       #6:3,R7
      1139:    {
      1140:        int i, j, k, l, numw;
      1141:        unsigned char chr[6], temp, sign;
      1142:        
      1143:        if( figure > 8 ) return;
  00000F58 0D14                   MOV.W       R1,R4
  00000F5A 0D8D                   MOV.W       E0,E5
  00000F5C 0D02                   MOV.W       R0,R2
  00000F5E 79280008               CMP.W       #8:16,E0
  00000F62 58200000               BHI         L7234:16
      1144:        
      1145:        if( num < 0)
  00000F66 0D22                   MOV.W       R2,R2
  00000F68 4C00                   BGE         L7236:8
      1146:        {
      1147:            num = (~num) + 1;
  00000F6A 1792                   NEG.W       R2
      1148:            sign = 1;
  00000F6C 4001                   BRA/S       L7237:8
  00000F6E FE01                   MOV.B       #1:8,R6L
  00000F70                    L7236:                                
      1149:        }
      1150:        else
      1151:        {
      1152:            sign = 0;
  00000F70 18EE                   SUB.B       R6L,R6L
  00000F72                    L7237:                                
      1153:        }
      1154:        
      1155:        numw = num;
  00000F72 0D29                   MOV.W       R2,E1
      1156:        if(dp > 0)
  00000F74 0D44                   MOV.W       R4,R4
  00000F76 4700                   BEQ         L7239:8
      1157:        {
      1158:            for(i = 1; i <= dp; i ++ )
  00000F78 4001                   BRA/S       L7240:8
  00000F7A 0F10                   MOV.W       #1:3,R0
  00000F7C                    L7241:                                
      1159:            {
      1160:                numw = numw / 10;
  00000F7C 01D651A9               DIVS.W      #H'A:4,E1
  00000F80 0B50                   INC.W       #1,R0
  00000F82                    L7240:                                
  00000F82 1D40                   CMP.W       R4,R0
  00000F84 4300                   BLS         L7241:8
  00000F86                    L7239:                                
      1161:            }
      1162:        }
      1163:        
      1164:        i = 0;
  00000F86 19AA                   SUB.W       E2,E2
      1165:        l = 0;
      1166:        if(numw >= 10)
  00000F88 7929000A               CMP.W       #H'000A:16,E1
  00000F8C 4C00                   BGE         L7243:8
  00000F8E 0D45                   MOV.W       R4,R5
  00000F90 0B55                   INC.W       #1,R5
  00000F92 19CC                   SUB.W       E4,E4
  00000F94                    L7244:                                
      1167:        {
      1168:            do                              // 各桁数値の抽出ループ
      1169:            {
      1170:                temp = num % 10;            // 下位の桁から数字を抽出
      1171:                chr[i ++ ] = temp + '0';    // 数字を文字コードに変換
      1172:                if(i == dp)                 // 小数点位置の場合
      1173:                chr[i ++ ] = '.';           // 小数点を格納
      1174:            } while (( num /= 10 ) != 0);   // 数値の桁数までループ
      1175:        }
      1176:        else
      1177:        {
      1178:            do                              // 各桁数値の抽出ループ
      1179:            {
      1180:                temp = num % 10;            // 下位の桁から数字を抽出
      1181:                chr[i ++ ] = temp + '0';    // 数字を文字コードに変換
  00000F94 0D20                   MOV.W       R2,R0
  00000F96 17F0                   EXTS.L      ER0
  00000F98 01D453A0               DIVXS.W     #H'A:4,ER0
  00000F9C 0D80                   MOV.W       E0,R0
  00000F9E 0C81                   MOV.B       R0L,R1H
  00000FA0 8130                   ADD.B       #H'30:8,R1H
  00000FA2 0DA0                   MOV.W       E2,R0
  00000FA4 17F0                   EXTS.L      ER0
  00000FA6 0AF0                   ADD.L       SP,ER0
  00000FA8 6881                   MOV.B       R1H,@ER0
  00000FAA 0B5A                   INC.W       #1,E2
      1182:                if(i == dp)                 // 小数点位置の場合
  00000FAC 1D4A                   CMP.W       R4,E2
  00000FAE 4600                   BNE         L7246:8
      1183:                {
      1184:                chr[i ++ ] = '.';           // 小数点を格納
  00000FB0 0DA0                   MOV.W       E2,R0
  00000FB2 17F0                   EXTS.L      ER0
  00000FB4 0AF0                   ADD.L       SP,ER0
  00000FB6 017D002E               MOV.B       #H'2E:8,@ER0
  00000FBA 0B5A                   INC.W       #1,E2
      1185:                l = 1;
  00000FBC 0F1C                   MOV.W       #1:3,E4
  00000FBE                    L7246:                                
      1186:                }
      1187:                num /= 10;
  00000FBE 01D651A2               DIVS.W      #H'A:4,R2
  00000FC2 0DC9                   MOV.W       E4,E1
  00000FC4 0959                   ADD.W       R5,E1
  00000FC6 1D9A                   CMP.W       E1,E2
  00000FC8 4700                   BEQ         L7247:8
  00000FCA 4000                   BRA         L7244:8
  00000FCC                    L7243:                                
  00000FCC 0D20                   MOV.W       R2,R0
  00000FCE 17F0                   EXTS.L      ER0
  00000FD0 01D453A0               DIVXS.W     #H'A:4,ER0
  00000FD4 0D80                   MOV.W       E0,R0
  00000FD6 0C81                   MOV.B       R0L,R1H
  00000FD8 8130                   ADD.B       #H'30:8,R1H
  00000FDA 0DA0                   MOV.W       E2,R0
  00000FDC 17F0                   EXTS.L      ER0
  00000FDE 0AF0                   ADD.L       SP,ER0
  00000FE0 6881                   MOV.B       R1H,@ER0
  00000FE2 0B5A                   INC.W       #1,E2
  00000FE4 1D4A                   CMP.W       R4,E2
  00000FE6 4600                   BNE         L7249:8
  00000FE8 0DA1                   MOV.W       E2,R1
  00000FEA 17F1                   EXTS.L      ER1
  00000FEC 0FF0                   MOV.L       SP,ER0
  00000FEE 0AF1                   ADD.L       SP,ER1
  00000FF0 017D012E               MOV.B       #H'2E:8,@ER1
  00000FF4 0B5A                   INC.W       #1,E2
  00000FF6                    L7249:                                
  00000FF6 01D651A2               DIVS.W      #H'A:4,R2
  00000FFA 0D22                   MOV.W       R2,R2
  00000FFC 4600                   BNE         L7243:8
  00000FFE                    L7247:                                
      1188:            } while (i != (dp + 1 + l));        // 数値の桁数までループ
      1189:        }
      1190:        
      1191:        i --;
  00000FFE 1B5A                   DEC.W       #1,E2
      1192:        
      1193:        if((figure - 1) < i)                //表示桁数チェック
  00001000 0DD8                   MOV.W       E5,E0
  00001002 1B5D                   DEC.W       #1,E5
  00001004 0DD0                   MOV.W       E5,R0
  00001006 1DAD                   CMP.W       E2,E5
  00001008 4500                   BLO         L7234:8
      1194:        {
      1195:            return;
      1196:        }
      1197:        
      1198:        if(i == (figure - 1))               //MAX桁の場合
  0000100A 1D0A                   CMP.W       R0,E2
  0000100C 4600                   BNE         L7252:8
      1199:        {
      1200:            i += 1;                         //頭の桁を１つ増やす
  0000100E 0B5A                   INC.W       #1,E2
      1201:            if(sign == 1)
  00001010 0DA0                   MOV.W       E2,R0
  00001012 17F0                   EXTS.L      ER0
  00001014 0AF0                   ADD.L       SP,ER0
  00001016 AE01                   CMP.B       #1:8,R6L
  00001018 4600                   BNE         L7254:8
      1202:            {
      1203:                chr[i] = '-';               //頭桁に-記号付加
  0000101A 017D002D               MOV.B       #H'2D:8,@ER0
  0000101E 4000                   BRA         L7255:8
  00001020                    L7254:                                
      1204:            }
      1205:            else
      1206:            {
      1207:                chr[i] = ' ';               //頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
  00001020 017D0020               MOV.B       #H'20:8,@ER0
  00001024 4000                   BRA         L7255:8
  00001026                    L7252:                                
      1208:            }
      1209:        }
      1210:        else
      1211:        {                                   //MAX桁以下の場合
      1212:            for( j = 0; j < ((figure) -i ); j++ )       //最初に頭から不足桁数分のｽﾍﾟｰｽ付加
  00001026 1922                   SUB.W       R2,R2
  00001028 0D84                   MOV.W       E0,R4
  0000102A 19A4                   SUB.W       E2,R4
  0000102C 0D0C                   MOV.W       R0,E4
  0000102E 4001                   BRA/S       L7256:8
  00001030 19AC                   SUB.W       E2,E4
  00001032                    L7257:                                
      1213:            {
      1214:                if(j == ((figure - 1) - i ))//数値頭の±符号処理
  00001032 1DC2                   CMP.W       E4,R2
  00001034 4600                   BNE         L7259:8
      1215:                {
      1216:                    if(sign == 1)
  00001036 AE01                   CMP.B       #1:8,R6L
  00001038 4600                   BNE         L7259:8
      1217:                    {
      1218:                        LCD_CHR_copyBNR('-');   //頭桁に-記号付加
  0000103A 4001                   BRA/S       L7261:8
  0000103C F82D                   MOV.B       #H'2D:8,R0L
  0000103E                    L7259:                                
  0000103E F820                   MOV.B       #H'20:8,R0L
  00001040                    L7261:                                
  00001040 5E000000               JSR         @_LCD_CHR_copyBNR:24
  00001044 0B52                   INC.W       #1,R2
  00001046                    L7256:                                
  00001046 1D42                   CMP.W       R4,R2
  00001048 4500                   BLO         L7257:8
  0000104A                    L7255:                                
      1219:                    }
      1220:                    else
      1221:                    {
      1222:                        LCD_CHR_copyBNR(' ');   //頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
      1223:                    }
      1224:                }
      1225:                else
      1226:                {
      1227:                    LCD_CHR_copyBNR(' ');   //不足桁数だけスペース表示
      1228:                }            
      1229:            }
      1230:        }
      1231:        // 数字コード表示ルーチン
      1232:        for(k = i; k >= 0; k --)            // 上位の桁から順次
  0000104A 4001                   BRA/S       L7262:8
  0000104C 0DA2                   MOV.W       E2,R2
  0000104E                    L7263:                                
      1233:        {
      1234:            LCD_CHR_copyBNR(chr[k]);
  0000104E 0D20                   MOV.W       R2,R0
  00001050 17F0                   EXTS.L      ER0
  00001052 0AF0                   ADD.L       SP,ER0
  00001054 6808                   MOV.B       @ER0,R0L
  00001056 5E000000               JSR         @_LCD_CHR_copyBNR:24
  0000105A 1A12                   SUB.W       #1:3,R2
  0000105C                    L7262:                                
  0000105C 0D22                   MOV.W       R2,R2
  0000105E 4C00                   BGE         L7263:8
  00001060                    L7234:                                
  00001060 0A67                   ADD.W       #6:3,R7
  00001062 6D76                   POP.W       R6
  00001064 5435                   RTS/L       (ER2-ER5)
      1235:        }
      1236:    }
      1237:    
      1238:    // --------------------------------------------------------------------
      1239:    // TFT LCD 整数値出力（大き目2倍）
      1240:    // --------------------------------------------------------------------
      1241:    void LCD_INT_drawBN2(int num, unsigned int figure, unsigned int dp)
  00001066                    _LCD_INT_drawBN2:                    ; function: LCD_INT_drawBN2
  00001066 01306DF2               STM.L       (ER2-ER5),@-SP
  0000106A 6DF6                   PUSH.W      R6
  0000106C 1A67                   SUB.W       #6:3,R7
      1242:    {
      1243:        int i, j, k, l, numw;
      1244:        unsigned char chr[6], temp, sign;
      1245:        
      1246:        if( figure > 8 ) return;
  0000106E 0D14                   MOV.W       R1,R4
  00001070 0D8D                   MOV.W       E0,E5
  00001072 0D02                   MOV.W       R0,R2
  00001074 79280008               CMP.W       #8:16,E0
  00001078 58200000               BHI         L7266:16
      1247:        
      1248:        if( num < 0)
  0000107C 0D22                   MOV.W       R2,R2
  0000107E 4C00                   BGE         L7268:8
      1249:        {
      1250:            num = (~num) + 1;
  00001080 1792                   NEG.W       R2
      1251:            sign = 1;
  00001082 4001                   BRA/S       L7269:8
  00001084 FE01                   MOV.B       #1:8,R6L
  00001086                    L7268:                                
      1252:        }
      1253:        else
      1254:        {
      1255:            sign = 0;
  00001086 18EE                   SUB.B       R6L,R6L
  00001088                    L7269:                                
      1256:        }
      1257:        
      1258:        numw = num;
  00001088 0D29                   MOV.W       R2,E1
      1259:        if(dp > 0)
  0000108A 0D44                   MOV.W       R4,R4
  0000108C 4700                   BEQ         L7271:8
      1260:        {
      1261:            for(i = 1; i <= dp; i ++ )
  0000108E 4001                   BRA/S       L7272:8
  00001090 0F10                   MOV.W       #1:3,R0
  00001092                    L7273:                                
      1262:            {
      1263:                numw = numw / 10;
  00001092 01D651A9               DIVS.W      #H'A:4,E1
  00001096 0B50                   INC.W       #1,R0
  00001098                    L7272:                                
  00001098 1D40                   CMP.W       R4,R0
  0000109A 4300                   BLS         L7273:8
  0000109C                    L7271:                                
      1264:            }
      1265:        }
      1266:        
      1267:        i = 0;
  0000109C 19AA                   SUB.W       E2,E2
      1268:        l = 0;
      1269:        if(numw >= 10)
  0000109E 7929000A               CMP.W       #H'000A:16,E1
  000010A2 4C00                   BGE         L7275:8
  000010A4 0D45                   MOV.W       R4,R5
  000010A6 0B55                   INC.W       #1,R5
  000010A8 19CC                   SUB.W       E4,E4
  000010AA                    L7276:                                
      1270:        {
      1271:            do                              // 各桁数値の抽出ループ
      1272:            {
      1273:                temp = num % 10;            // 下位の桁から数字を抽出
      1274:                chr[i ++ ] = temp + '0';    // 数字を文字コードに変換
      1275:                if(i == dp)                 // 小数点位置の場合
      1276:                chr[i ++ ] = '.';           // 小数点を格納
      1277:            } while (( num /= 10 ) != 0);   // 数値の桁数までループ
      1278:        }
      1279:        else
      1280:        {
      1281:            do                              // 各桁数値の抽出ループ
      1282:            {
      1283:                temp = num % 10;            // 下位の桁から数字を抽出
      1284:                chr[i ++ ] = temp + '0';    // 数字を文字コードに変換
  000010AA 0D20                   MOV.W       R2,R0
  000010AC 17F0                   EXTS.L      ER0
  000010AE 01D453A0               DIVXS.W     #H'A:4,ER0
  000010B2 0D80                   MOV.W       E0,R0
  000010B4 0C81                   MOV.B       R0L,R1H
  000010B6 8130                   ADD.B       #H'30:8,R1H
  000010B8 0DA0                   MOV.W       E2,R0
  000010BA 17F0                   EXTS.L      ER0
  000010BC 0AF0                   ADD.L       SP,ER0
  000010BE 6881                   MOV.B       R1H,@ER0
  000010C0 0B5A                   INC.W       #1,E2
      1285:                if(i == dp)                 // 小数点位置の場合
  000010C2 1D4A                   CMP.W       R4,E2
  000010C4 4600                   BNE         L7278:8
      1286:                {
      1287:                chr[i ++ ] = '.';           // 小数点を格納
  000010C6 0DA0                   MOV.W       E2,R0
  000010C8 17F0                   EXTS.L      ER0
  000010CA 0AF0                   ADD.L       SP,ER0
  000010CC 017D002E               MOV.B       #H'2E:8,@ER0
  000010D0 0B5A                   INC.W       #1,E2
      1288:                l = 1;
  000010D2 0F1C                   MOV.W       #1:3,E4
  000010D4                    L7278:                                
      1289:                }
      1290:                num /= 10;
  000010D4 01D651A2               DIVS.W      #H'A:4,R2
  000010D8 0DC9                   MOV.W       E4,E1
  000010DA 0959                   ADD.W       R5,E1
  000010DC 1D9A                   CMP.W       E1,E2
  000010DE 4700                   BEQ         L7279:8
  000010E0 4000                   BRA         L7276:8
  000010E2                    L7275:                                
  000010E2 0D20                   MOV.W       R2,R0
  000010E4 17F0                   EXTS.L      ER0
  000010E6 01D453A0               DIVXS.W     #H'A:4,ER0
  000010EA 0D80                   MOV.W       E0,R0
  000010EC 0C81                   MOV.B       R0L,R1H
  000010EE 8130                   ADD.B       #H'30:8,R1H
  000010F0 0DA0                   MOV.W       E2,R0
  000010F2 17F0                   EXTS.L      ER0
  000010F4 0AF0                   ADD.L       SP,ER0
  000010F6 6881                   MOV.B       R1H,@ER0
  000010F8 0B5A                   INC.W       #1,E2
  000010FA 1D4A                   CMP.W       R4,E2
  000010FC 4600                   BNE         L7281:8
  000010FE 0DA1                   MOV.W       E2,R1
  00001100 17F1                   EXTS.L      ER1
  00001102 0FF0                   MOV.L       SP,ER0
  00001104 0AF1                   ADD.L       SP,ER1
  00001106 017D012E               MOV.B       #H'2E:8,@ER1
  0000110A 0B5A                   INC.W       #1,E2
  0000110C                    L7281:                                
  0000110C 01D651A2               DIVS.W      #H'A:4,R2
  00001110 0D22                   MOV.W       R2,R2
  00001112 4600                   BNE         L7275:8
  00001114                    L7279:                                
      1291:            } while (i != (dp + 1 + l));        // 数値の桁数までループ
      1292:        }
      1293:        
      1294:        i --;
  00001114 1B5A                   DEC.W       #1,E2
      1295:        
      1296:        if((figure - 1) < i)                //表示桁数チェック
  00001116 0DD8                   MOV.W       E5,E0
  00001118 1B5D                   DEC.W       #1,E5
  0000111A 0DD0                   MOV.W       E5,R0
  0000111C 1DAD                   CMP.W       E2,E5
  0000111E 4500                   BLO         L7266:8
      1297:        {
      1298:            return;
      1299:        }
      1300:        
      1301:        if(i == (figure - 1))               //MAX桁の場合
  00001120 1D0A                   CMP.W       R0,E2
  00001122 4600                   BNE         L7284:8
      1302:        {
      1303:            i += 1;                         //頭の桁を１つ増やす
  00001124 0B5A                   INC.W       #1,E2
      1304:            if(sign == 1)
  00001126 0DA0                   MOV.W       E2,R0
  00001128 17F0                   EXTS.L      ER0
  0000112A 0AF0                   ADD.L       SP,ER0
  0000112C AE01                   CMP.B       #1:8,R6L
  0000112E 4600                   BNE         L7286:8
      1305:            {
      1306:                chr[i] = '-';               //頭桁に-記号付加
  00001130 017D002D               MOV.B       #H'2D:8,@ER0
  00001134 4000                   BRA         L7287:8
  00001136                    L7286:                                
      1307:            }
      1308:            else
      1309:            {
      1310:                chr[i] = ' ';               //頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
  00001136 017D0020               MOV.B       #H'20:8,@ER0
  0000113A 4000                   BRA         L7287:8
  0000113C                    L7284:                                
      1311:            }
      1312:        }
      1313:        else
      1314:        {                                   //MAX桁以下の場合
      1315:            for( j = 0; j < ((figure) -i ); j++ )       //最初に頭から不足桁数分のｽﾍﾟｰｽ付加
  0000113C 1922                   SUB.W       R2,R2
  0000113E 0D84                   MOV.W       E0,R4
  00001140 19A4                   SUB.W       E2,R4
  00001142 0D0C                   MOV.W       R0,E4
  00001144 4001                   BRA/S       L7288:8
  00001146 19AC                   SUB.W       E2,E4
  00001148                    L7289:                                
      1316:            {
      1317:                if(j == ((figure - 1) - i ))//数値頭の±符号処理
  00001148 1DC2                   CMP.W       E4,R2
  0000114A 4600                   BNE         L7291:8
      1318:                {
      1319:                    if(sign == 1)
  0000114C AE01                   CMP.B       #1:8,R6L
  0000114E 4600                   BNE         L7291:8
      1320:                    {
      1321:                        LCD_CHR_copyBN2('-');   //頭桁に-記号付加
  00001150 4001                   BRA/S       L7293:8
  00001152 F82D                   MOV.B       #H'2D:8,R0L
  00001154                    L7291:                                
  00001154 F820                   MOV.B       #H'20:8,R0L
  00001156                    L7293:                                
  00001156 5E000000               JSR         @_LCD_CHR_copyBN2:24
  0000115A 0B52                   INC.W       #1,R2
  0000115C                    L7288:                                
  0000115C 1D42                   CMP.W       R4,R2
  0000115E 4500                   BLO         L7289:8
  00001160                    L7287:                                
      1322:                    }
      1323:                    else
      1324:                    {
      1325:                        LCD_CHR_copyBN2(' ');   //頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
      1326:                    }
      1327:                }
      1328:                else
      1329:                {
      1330:                    LCD_CHR_copyBN2(' ');   //不足桁数だけスペース表示
      1331:                }            
      1332:            }
      1333:        }
      1334:        // 数字コード表示ルーチン
      1335:        for(k = i; k >= 0; k --)            // 上位の桁から順次
  00001160 4001                   BRA/S       L7294:8
  00001162 0DA2                   MOV.W       E2,R2
  00001164                    L7295:                                
      1336:        {
      1337:            LCD_CHR_copyBN2(chr[k]);
  00001164 0D20                   MOV.W       R2,R0
  00001166 17F0                   EXTS.L      ER0
  00001168 0AF0                   ADD.L       SP,ER0
  0000116A 6808                   MOV.B       @ER0,R0L
  0000116C 5E000000               JSR         @_LCD_CHR_copyBN2:24
  00001170 1A12                   SUB.W       #1:3,R2
  00001172                    L7294:                                
  00001172 0D22                   MOV.W       R2,R2
  00001174 4C00                   BGE         L7295:8
  00001176                    L7266:                                
  00001176 0A67                   ADD.W       #6:3,R7
  00001178 6D76                   POP.W       R6
  0000117A 5435                   RTS/L       (ER2-ER5)
      1338:        }
      1339:    }
      1340:    
      1341:    /*
      1342:    // --------------------------------------------------------------------
      1343:    // 
      1344:    // --------------------------------------------------------------------
      1345:    void LCD_NUM_drawBN(int num, unsigned int figure)
      1346:    {
      1347:        int i, j, k, sign;
      1348:        unsigned char chr[6], temp;
      1349:        
      1350:        if( figure > 8 )
      1351:        {
      1352:            return;
      1353:        }
      1354:        
      1355:        if(num < 0)
      1356:        {
      1357:            num = (~num) + 1;
      1358:            sign = -1;
      1359:        }
      1360:        else
      1361:        {
      1362:            sign = 1;
      1363:        }
      1364:        
      1365:        
      1366:        i = 0;
      1367:        do                                  // 各桁数値の抽出ループ
      1368:        {
      1369:            temp = num % 10;                // 下位の桁から数字を抽出
      1370:            chr[i ++] = temp + '0';     // 数字を文字コードに変換
      1371:        } while (( num /= 10 ) != 0);       // 数値の桁数までループ
      1372:        i --;
      1373:            
      1374:        if((figure - 1) < i)                //表示桁数チェック
      1375:        {
      1376:            return;
      1377:        }
      1378:        
      1379:        if(i == (figure - 1))               //MAX桁の場合
      1380:        {
      1381:            i += 1;                         //頭の桁を１つ増やす
      1382:            if(sign == -1)                  //負数の場合
      1383:            {
      1384:                chr[i] = '-';               //頭桁に-記号付加
      1385:            }
      1386:            else
      1387:            {                               //正数の場合
      1388:                chr[i] = ' ';               //頭桁に-ｽﾍﾟｰｽ記号付加(+記号は付けない)
      1389:        //      chr[i] = '+';               //
      1390:            }
      1391:        }
      1392:        else
      1393:        {                                   //MAX桁以下の場合
      1394:            for( j = 0; j < ((figure) -i ); j++ )       //最初に頭から不足桁数分のｽﾍﾟｰｽ付加
      1395:            {
      1396:                if(j == ((figure - 1) - i ))//数値頭の±符号処理
      1397:                {
      1398:                    if(sign == -1)          //負数の場合
      1399:                    {
      1400:                        LCD_CHR_copyBN('-');//頭桁に-記号付加
      1401:                    }
      1402:                    else                    //正数の場合
      1403:                    {
      1404:                        LCD_CHR_copyBN(' ');//頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
      1405:        //              LCD_CHR_copyBN('+');//
      1406:                    }
      1407:                }
      1408:                else
      1409:                {
      1410:                    LCD_CHR_copyBN(' ');    //不足桁数だけスペース表示
      1411:                }            
      1412:            }
      1413:        }
      1414:        // 数字コード表示ルーチン
      1415:        for(k = i; k >= 0; k --)            // 上位の桁から順次
      1416:        {
      1417:            LCD_CHR_copyBN(chr[k]);
      1418:        }
      1419:        
      1420:    }
      1421:    */
      1422:    
      1423:    /*
      1424:    // --------------------------------------------------------------------
      1425:    // 
      1426:    // --------------------------------------------------------------------
      1427:    void LCD_NUM_drawBNF(int num, unsigned int figure, unsigned int f)
      1428:    {
      1429:        int i, j, k, sign;
      1430:        unsigned char chr[6], temp;
      1431:        
      1432:        if( figure > 8 )
      1433:        {
      1434:            return;
      1435:        }
      1436:        
      1437:        if(num < 0)
      1438:        {
      1439:            num = (~num) + 1;
      1440:            sign = -1;
      1441:        }
      1442:        else
      1443:        {
      1444:            sign = 1;
      1445:        }
      1446:        
      1447:        
      1448:        i = 0;
      1449:        do                                  // 各桁数値の抽出ループ
      1450:        {
      1451:            temp = num % 10;                // 下位の桁から数字を抽出
      1452:            chr[i ++] = temp + '0';     // 数字を文字コードに変換
      1453:        } while (( num /= 10 ) != 0);       // 数値の桁数までループ
      1454:        i --;
      1455:            
      1456:        if((figure - 1) < i)                //表示桁数チェック
      1457:        {
      1458:            return;
      1459:        }
      1460:        
      1461:        if(i == (figure - 1))               //MAX桁の場合
      1462:        {
      1463:            i += 1;                         //頭の桁を１つ増やす
      1464:            if(sign == -1)                  //負数の場合
      1465:            {
      1466:                chr[i] = '-';               //頭桁に-記号付加
      1467:            }
      1468:            else
      1469:            {                               //正数の場合
      1470:                chr[i] = ' ';               //頭桁に-ｽﾍﾟｰｽ記号付加(+記号は付けない)
      1471:        //      chr[i] = '+';               //
      1472:            }
      1473:        }
      1474:        else
      1475:        {                                   //MAX桁以下の場合
      1476:            for( j = 0; j < ((figure) -i ); j++ )       //最初に頭から不足桁数分のｽﾍﾟｰｽ付加
      1477:            {
      1478:                if(j == ((figure - 1) - i ))//数値頭の±符号処理
      1479:                {
      1480:                    if(sign == -1)          //負数の場合
      1481:                    {
      1482:                        LCD_CHR_copyBN('-');//頭桁に-記号付加
      1483:                    }
      1484:                    else                    //正数の場合
      1485:                    {
      1486:                        LCD_CHR_copyBN(' ');//頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
      1487:        //              LCD_CHR_copyBN('+');//
      1488:                    }
      1489:                }
      1490:                else
      1491:                {
      1492:                    LCD_CHR_copyBN(' ');    //不足桁数だけスペース表示
      1493:                }            
      1494:            }
      1495:        }
      1496:        // 数字コード表示ルーチン
      1497:        for(k = i; k >= 0; k --)            // 上位の桁から順次
      1498:        {
      1499:            if(k == f)
      1500:            {
      1501:                if(f != 0)
      1502:                {
      1503:                    LCD_CHR_copyBN('.');
      1504:                    LCD_CHR_copyBN(chr[k]);
      1505:                }
      1506:            }
      1507:            else
      1508:            {
      1509:                LCD_CHR_copyBN(chr[k]);
      1510:            }
      1511:        }
      1512:        
      1513:    }
      1514:    */
      1515:    
      1516:    /*
      1517:    // --------------------------------------------------------------------
      1518:    // 
      1519:    // --------------------------------------------------------------------
      1520:    void LCD_CHR_copyBN2(unsigned char chr)
      1521:    {
      1522:        unsigned long i, j, font_addr;
      1523:        
      1524:        // フォントテーブルデータの座標の参照先を算出
      1525:        font_addr = (((((chr - 0x20) & 0x000000F0) >> 4) * 24) * 320) + ((((chr - 0x20) & 0x0000000F) * 16));
      1526:        
      1527:        for(j = 0; j < 24; j ++)
      1528:        {
      1529:            for(i = 0; i < 16; i ++)
      1530:            {
      1531:                if(g_drawbuff_flg)
      1532:                {
      1533:                    (*(ADATA + ((g_LCD_x + i * 2    ) + (g_LCD_y + j * 2    ) * 320))) = *(FONT + font_addr + i + j * 320);
      1534:                    (*(ADATA + ((g_LCD_x + i * 2 + 1) + (g_LCD_y + j * 2    ) * 320))) = *(FONT + font_addr + i + j * 320);
      1535:                    (*(ADATA + ((g_LCD_x + i * 2    ) + (g_LCD_y + j * 2 + 1) * 320))) = *(FONT + font_addr + i + j * 320);
      1536:                    (*(ADATA + ((g_LCD_x + i * 2 + 1) + (g_LCD_y + j * 2 + 1) * 320))) = *(FONT + font_addr + i + j * 320);
      1537:                }
      1538:                else
      1539:                {
      1540:                    (*(BDATA + ((g_LCD_x + i * 2    ) + (g_LCD_y + j * 2    ) * 320))) = *(FONT + font_addr + i + j * 320);
      1541:                    (*(BDATA + ((g_LCD_x + i * 2 + 1) + (g_LCD_y + j * 2    ) * 320))) = *(FONT + font_addr + i + j * 320);
      1542:                    (*(BDATA + ((g_LCD_x + i * 2    ) + (g_LCD_y + j * 2 + 1) * 320))) = *(FONT + font_addr + i + j * 320);
      1543:                    (*(BDATA + ((g_LCD_x + i * 2 + 1) + (g_LCD_y + j * 2 + 1) * 320))) = *(FONT + font_addr + i + j * 320);
      1544:                }
      1545:            }
      1546:        }
      1547:        g_LCD_x = g_LCD_x  + 32;
      1548:    }
      1549:    */
      1550:    
      1551:    /*
      1552:    // --------------------------------------------------------------------
      1553:    // 
      1554:    // --------------------------------------------------------------------
      1555:    void LCD_CHR_drawBN2(unsigned char chr[])
      1556:    {
      1557:        unsigned int i;
      1558:        
      1559:        for(i = 0; i <= 19; i++)
      1560:        {
      1561:            if(chr[i] == '\0') return;
      1562:            LCD_CHR_copyBN2(chr[i]);
      1563:        }
      1564:    }
      1565:    */
      1566:    
      1567:    /*
      1568:    // --------------------------------------------------------------------
      1569:    // 
      1570:    // --------------------------------------------------------------------
      1571:    void LCD_NUM_drawBN2(int num, unsigned int figure)
      1572:    {
      1573:        int i, j, k, sign;
      1574:        unsigned char chr[6], temp;
      1575:        
      1576:        if( figure > 8 )
      1577:        {
      1578:            return;
      1579:        }
      1580:        
      1581:        if(num < 0)
      1582:        {
      1583:            num = (~num) + 1;
      1584:            sign = -1;
      1585:        }
      1586:        else
      1587:        {
      1588:            sign = 1;
      1589:        }
      1590:        
      1591:        
      1592:        i = 0;
      1593:        do                                  // 各桁数値の抽出ループ
      1594:        {
      1595:            temp = num % 10;                // 下位の桁から数字を抽出
      1596:            chr[i ++] = temp + '0';     // 数字を文字コードに変換
      1597:        } while (( num /= 10 ) != 0);       // 数値の桁数までループ
      1598:        i --;
      1599:            
      1600:        if((figure - 1) < i)                //表示桁数チェック
      1601:        {
      1602:            return;
      1603:        }
      1604:        
      1605:        if(i == (figure - 1))               //MAX桁の場合
      1606:        {
      1607:            i += 1;                         //頭の桁を１つ増やす
      1608:            if(sign == -1)                  //負数の場合
      1609:            {
      1610:                chr[i] = '-';               //頭桁に-記号付加
      1611:            }
      1612:            else
      1613:            {                               //正数の場合
      1614:                chr[i] = ' ';               //頭桁に-ｽﾍﾟｰｽ記号付加(+記号は付けない)
      1615:        //      chr[i] = '+';               //
      1616:            }
      1617:        }
      1618:        else
      1619:        {                                   //MAX桁以下の場合
      1620:            for( j = 0; j < ((figure) -i ); j++ )       //最初に頭から不足桁数分のｽﾍﾟｰｽ付加
      1621:            {
      1622:                if(j == ((figure - 1) - i ))//数値頭の±符号処理
      1623:                {
      1624:                    if(sign == -1)          //負数の場合
      1625:                    {
      1626:                        LCD_CHR_copyBN2('-');//頭桁に-記号付加
      1627:                    }
      1628:                    else                    //正数の場合
      1629:                    {
      1630:                        LCD_CHR_copyBN2(' ');//頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
      1631:        //              LCD_CHR_copyBN2('+');//
      1632:                    }
      1633:                }
      1634:                else
      1635:                {
      1636:                    LCD_CHR_copyBN2(' ');   //不足桁数だけスペース表示
      1637:                }            
      1638:            }
      1639:        }
      1640:        // 数字コード表示ルーチン
      1641:        for(k = i; k >= 0; k --)            // 上位の桁から順次
      1642:        {
      1643:            LCD_CHR_copyBN2(chr[k]);
      1644:        }
      1645:    }
      1646:    */
      1647:    
      1648:    /*
      1649:    // --------------------------------------------------------------------
      1650:    // 
      1651:    // --------------------------------------------------------------------
      1652:    void LCD_NUM_drawBN2F(int num, unsigned int figure, unsigned int f)
      1653:    {
      1654:        int i, j, k, sign;
      1655:        unsigned char chr[6], temp;
      1656:        
      1657:        if( figure > 8 )
      1658:        {
      1659:            return;
      1660:        }
      1661:        
      1662:        if(num < 0)
      1663:        {
      1664:            num = (~num) + 1;
      1665:            sign = -1;
      1666:        }
      1667:        else
      1668:        {
      1669:            sign = 1;
      1670:        }
      1671:        
      1672:        
      1673:        i = 0;
      1674:        do                                  // 各桁数値の抽出ループ
      1675:        {
      1676:            temp = num % 10;                // 下位の桁から数字を抽出
      1677:            chr[i ++] = temp + '0';     // 数字を文字コードに変換
      1678:        } while (( num /= 10 ) != 0);       // 数値の桁数までループ
      1679:        i --;
      1680:            
      1681:        if((figure - 1) < i)                //表示桁数チェック
      1682:        {
      1683:            return;
      1684:        }
      1685:        
      1686:        if(i == (figure - 1))               //MAX桁の場合
      1687:        {
      1688:            i += 1;                         //頭の桁を１つ増やす
      1689:            if(sign == -1)                  //負数の場合
      1690:            {
      1691:                chr[i] = '-';               //頭桁に-記号付加
      1692:            }
      1693:            else
      1694:            {                               //正数の場合
      1695:                chr[i] = ' ';               //頭桁に-ｽﾍﾟｰｽ記号付加(+記号は付けない)
      1696:        //      chr[i] = '+';               //
      1697:            }
      1698:        }
      1699:        else
      1700:        {                                   //MAX桁以下の場合
      1701:            for( j = 0; j < ((figure) -i ); j++ )       //最初に頭から不足桁数分のｽﾍﾟｰｽ付加
      1702:            {
      1703:                if(j == ((figure - 1) - i ))//数値頭の±符号処理
      1704:                {
      1705:                    if(sign == -1)          //負数の場合
      1706:                    {
      1707:                        LCD_CHR_copyBN2('-');//頭桁に-記号付加
      1708:                    }
      1709:                    else                    //正数の場合
      1710:                    {
      1711:                        LCD_CHR_copyBN2(' ');//頭桁にｽﾍﾟｰｽ記号付加(+記号は付けない)
      1712:        //              LCD_CHR_copyBN2('+');//
      1713:                    }
      1714:                }
      1715:                else
      1716:                {
      1717:                    LCD_CHR_copyBN2(' ');   //不足桁数だけスペース表示
      1718:                }            
      1719:            }
      1720:        }
      1721:        // 数字コード表示ルーチン
      1722:        for(k = i; k >= 0; k --)            // 上位の桁から順次
      1723:        {
      1724:            if(k == f)
      1725:            {
      1726:                if(f != 0)
      1727:                {
      1728:                    LCD_CHR_copyBN2('.');
      1729:                    LCD_CHR_copyBN2(chr[k]);
      1730:                }
      1731:            }
      1732:            else
      1733:            {
      1734:                LCD_CHR_copyBN2(chr[k]);
      1735:            }
      1736:        }
      1737:        
      1738:    }
      1739:    */
      1740:    
      1741:    /*
      1742:    // --------------------------------------------------------------------
      1743:    // 
      1744:    // --------------------------------------------------------------------
      1745:    void LCD_CHR_copyB(unsigned int x, unsigned int y, unsigned char chr, unsigned int color)
      1746:    {
      1747:        unsigned long   i, j, font_addr;
      1748:        unsigned long   dst_data, font_data;
      1749:        unsigned long   rd, gd, bd,rs, gs, bs, alpha;
      1750:        
      1751:        // フォントテーブルデータの座標の参照先を算出
      1752:        font_addr = (((((chr - 0x20) & 0x000000F0) >> 4) * 24) * 320) + ((((chr - 0x20) & 0x0000000F) * 16));
      1753:        
      1754:        for(j = 0; j < 24; j++)
      1755:        {
      1756:            for(i = 0; i < 16; i++)
      1757:            {
      1758:                if(DrawBuff_flg)
      1759:                {
      1760:                    dst_data    = (*(ADATA + ((x + i) + (y + j) * 320)));               // 貼り付け先データの該当ピクセルデータの算出
      1761:                }
      1762:                else
      1763:                {
      1764:                    dst_data    = (*(BDATA + ((x + i) + (y + j) * 320)));               // 貼り付け先データの該当ピクセルデータの算出
      1765:                }
      1766:                font_data   = (*(FONT +  + i + j * 320));                               // フォントテーブルデータの該当ピクセルデータの算出(アルファデータ)
      1767:                rd          = ((dst_data >> 11) & 0x001F);                              // 貼り付け先データのR要素の算出
      1768:                gd          = ((dst_data >>  5) & 0x003F);                              // 貼り付け先データのG要素の算出
      1769:                bd          = ((dst_data      ) & 0x001F);                              // 貼り付け先データのB要素の算出
      1770:                rs          = ((color         ) & 0x001F);                              // フォント指定色のR要素の算出
      1771:                gs          = ((color    >>  5) & 0x003F);                              // フォント指定色のG要素の算出
      1772:                bs          = ((color    >> 11) & 0x001F);                              // フォント指定色のB要素の算出
      1773:                alpha       = font_data & 0x1F;                                         // フォントテーブルデータからアルファ量を算出
      1774:                rd          = (rd *  alpha       + rs * (0x1F -  alpha      )) / 0x1F;  // R要素のアルファブレンド
      1775:                gd          = (gd * (alpha << 1) + gs * (0x3F - (alpha << 1))) / 0x3F;  // G要素のアルファブレンド
      1776:                bd          = (bd *  alpha       + bs * (0x1F -  alpha      )) / 0x1F;  // B要素のアルファブレンド
      1777:                dst_data    = (rd << 11) | (gd << 5) | bd;  
      1778:                if(DrawBuff_flg)
      1779:                {
      1780:                    (*(ADATA + ((x + i) + (y + j) * 320))) = dst_data;
      1781:                }
      1782:                else
      1783:                {
      1784:                    (*(BDATA + ((x + i) + (y + j) * 320))) = dst_data;
      1785:                }
      1786:            }
      1787:        }
      1788:    }
      1789:    */
      1790:    
      1791:    /*
      1792:    // --------------------------------------------------------------------
      1793:    // 
      1794:    // --------------------------------------------------------------------
      1795:    void LCD_CHR_drawB(unsigned int x, unsigned int y, unsigned char chr[], unsigned int color)
      1796:    {
      1797:        unsigned int i;
      1798:        
      1799:        for(i = 0; i <= 19; i++)
      1800:        {
      1801:            if(chr[i] == '\0') return;
      1802:            LCD_CHR_copyB(x + i * 16, y, chr[i], color);
      1803:        }
      1804:    }
      1805:    */
B                                                                  ; section
  00000000                    __$y$23:                             ; static: y
  00000000 00000004               .RES.L      1
  00000004                    __$z$24:                             ; static: z
  00000004 00000004               .RES.L      1
  00000008                    __$y$27:                             ; static: y
  00000008 00000004               .RES.L      1
  0000000C                    __$z$28:                             ; static: z
  0000000C 00000004               .RES.L      1
  00000010                    __$icnt$31:                          ; static: icnt
  00000010 00000004               .RES.L      1
  00000014                    _g_LCD_x:                            ; static: g_LCD_x
  00000014 00000002               .RES.W      1
  00000016                    _g_LCD_y:                            ; static: g_LCD_y
  00000016 00000002               .RES.W      1
  00000018                    _g_drawbuff_flg:                     ; static: g_drawbuff_flg
  00000018 00000002               .RES.W      1
  0000001A                    _g_oneshot_flg:                      ; static: g_oneshot_flg
  0000001A 00000002               .RES.W      1


